{"version":3,"file":"audio-waveform-player-element.standalone.umd.min.js","sources":["../node_modules/umap/esm/index.js","../node_modules/uparser/esm/index.js","../node_modules/uarray/esm/index.js","../node_modules/uwire/esm/index.js","../node_modules/@ungap/create-content/esm/index.js","../node_modules/uhtml/esm/node.js","../node_modules/uhtml/esm/handlers.js","../node_modules/udomdiff/esm/index.js","../node_modules/uhandlers/esm/index.js","../node_modules/uhtml/esm/rabbit.js","../node_modules/uhtml/esm/index.js","../src/helpers/checkPassiveEventListener.js","../src/helpers/focus-visible.js","../node_modules/mp3-parser/lib/lib.js","../node_modules/mp3-parser/lib/id3v2.js","../node_modules/mp3-parser/lib/xing.js","../node_modules/mp3-parser/main.js","../node_modules/@soundcut/decode-audio-data-fast/dist/decode-audio-data-fast.esm.js","../src/helpers/getFileArrayBuffer.js","../src/helpers/getFileAudioBuffer.js","../src/helpers/withMediaSession.js","../node_modules/punycode/punycode.js","../src/helpers/hexToRGB.js","../src/AudioWaveformPlayer.js","../src/helpers/fetchSource.js","../src/helpers/formatTime.js","../src/helpers/getDisplayName.js","../src/components/Icons/Play.js","../src/components/Icons/Pause.js","../src/index.js"],"sourcesContent":["export default _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere ðŸ‘\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n","const attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nexport default (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n","const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n","import {slice} from 'uarray';\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n","/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {'use strict';\n  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\nexport default createContent;\n","import createContent from '@ungap/create-content';\nimport {indexOf} from 'uarray';\n\n// from a generic path, retrieves the exact targeted node\nexport const reducePath = ({childNodes}, i) => childNodes[i];\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nexport const createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\nconst {createTreeWalker, importNode} = document;\nexport {createTreeWalker, importNode};\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst IE = importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nexport const createFragment = IE ?\n  (text, type) => importNode.call(\n    document,\n    createContent(text, type),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nexport const createWalker = IE ?\n  fragment => createTreeWalker.call(document, fragment, 1 | 128, null, false) :\n  fragment => createTreeWalker.call(document, fragment, 1 | 128);\n","import {isArray, slice} from 'uarray';\nimport udomdiff from 'udomdiff';\nimport {aria, attribute, data, event, ref, setter, text} from 'uhandlers';\nimport {diffable} from 'uwire';\n\nimport {reducePath} from './node.js';\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (text)\n            text.textContent = newValue;\n          else\n            text = document.createTextNode(newValue);\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if ('ELEMENT_NODE' in newValue && oldValue !== newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  if (name === 'ref')\n    return ref(node);\n\n  if (name === 'aria')\n    return aria(node);\n\n  if (name === '.dataset')\n    return data(node);\n\n  if (name.slice(0, 1) === '.')\n    return setter(node, name.slice(1));\n\n  if (name.slice(0, 2) === 'on')\n    return event(node, name);\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap ðŸ‘)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","import {isArray} from 'uarray';\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = newValue;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, type = name.slice(2);\n  if (!(name in node) && name.toLowerCase() in node)\n    type = type.toLowerCase();\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => value => {\n  if (typeof value === 'function')\n    value(node);\n  else\n    value.current = node;\n};\n\nexport const setter = (node, key) => value => {\n  node[key] = value;\n};\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n","import umap from 'umap';\nimport instrument from 'uparser';\nimport {isArray} from 'uarray';\nimport {persistent} from 'uwire';\n\nimport {handlers} from './handlers.js';\nimport {createFragment, createPath, createWalker, importNode} from './node.js';\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isÂµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isÂµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isÂµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isÂµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isÂµ0=\"attr\" isÂµ1=\"other\"><!--isÂµ2--><style><!--isÂµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isÂµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.textContent === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isÂµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isÂµX\")\n      // the isÂµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style or a textarea one, check its content\n      // and if it is <!--isÂµX--> then update tex-only this node\n      if (\n        /^(?:style|textarea)$/i.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode.call(document, content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport function Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n};\n","import umap from 'umap';\nimport {Hole, createCache, unroll} from './rabbit.js';\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n","export const checkPassiveEventListener = (() => {\n  let passiveSupported;\n  return function checkPassiveEventListener_() {\n    if (passiveSupported !== undefined) {\n      return passiveSupported;\n    }\n\n    try {\n      const options = {\n        // eslint-disable-next-line getter-return\n        get passive() {\n          passiveSupported = true;\n        },\n      };\n\n      window.addEventListener('test', options, options);\n      window.removeEventListener('test', options, options);\n    } catch (err) {\n      passiveSupported = false;\n    }\n\n    return passiveSupported;\n  };\n})();\n","/**\n * Applies the :focus-visible polyfill at the given scope.\n * A scope in this case is either the top-level Document or a Shadow Root.\n *\n * @param {(Document|ShadowRoot)} scope\n * @see https://github.com/WICG/focus-visible\n */\nexport function applyFocusVisiblePolyfill(scope) {\n  var hadKeyboardEvent = true;\n  var hadFocusVisibleRecently = false;\n  var hadFocusVisibleRecentlyTimeout = null;\n\n  var inputTypesAllowlist = {\n    text: true,\n    search: true,\n    url: true,\n    tel: true,\n    email: true,\n    password: true,\n    number: true,\n    date: true,\n    month: true,\n    week: true,\n    time: true,\n    datetime: true,\n    'datetime-local': true,\n  };\n\n  /**\n   * Helper function for legacy browsers and iframes which sometimes focus\n   * elements like document, body, and non-interactive SVG.\n   * @param {Element} el\n   */\n  function isValidFocusTarget(el) {\n    if (\n      el &&\n      el !== document &&\n      el.nodeName !== 'HTML' &&\n      el.nodeName !== 'BODY' &&\n      'classList' in el &&\n      'contains' in el.classList\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes whether the given element should automatically trigger the\n   * `focus-visible` class being added, i.e. whether it should always match\n   * `:focus-visible` when focused.\n   * @param {Element} el\n   * @return {boolean}\n   */\n  function focusTriggersKeyboardModality(el) {\n    var type = el.type;\n    var tagName = el.tagName;\n\n    if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {\n      return true;\n    }\n\n    if (tagName === 'TEXTAREA' && !el.readOnly) {\n      return true;\n    }\n\n    if (el.isContentEditable) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add the `focus-visible` class to the given element if it was not added by\n   * the author.\n   * @param {Element} el\n   */\n  function addFocusVisibleClass(el) {\n    if (el.classList.contains('focus-visible')) {\n      return;\n    }\n    el.classList.add('focus-visible');\n    el.setAttribute('data-focus-visible-added', '');\n  }\n\n  /**\n   * Remove the `focus-visible` class from the given element if it was not\n   * originally added by the author.\n   * @param {Element} el\n   */\n  function removeFocusVisibleClass(el) {\n    if (!el.hasAttribute('data-focus-visible-added')) {\n      return;\n    }\n    el.classList.remove('focus-visible');\n    el.removeAttribute('data-focus-visible-added');\n  }\n\n  /**\n   * If the most recent user interaction was via the keyboard;\n   * and the key press did not include a meta, alt/option, or control key;\n   * then the modality is keyboard. Otherwise, the modality is not keyboard.\n   * Apply `focus-visible` to any current active element and keep track\n   * of our keyboard modality state with `hadKeyboardEvent`.\n   * @param {KeyboardEvent} e\n   */\n  function onKeyDown(e) {\n    if (e.metaKey || e.altKey || e.ctrlKey) {\n      return;\n    }\n\n    if (isValidFocusTarget(scope.activeElement)) {\n      addFocusVisibleClass(scope.activeElement);\n    }\n\n    hadKeyboardEvent = true;\n  }\n\n  /**\n   * If at any point a user clicks with a pointing device, ensure that we change\n   * the modality away from keyboard.\n   * This avoids the situation where a user presses a key on an already focused\n   * element, and then clicks on a different element, focusing it with a\n   * pointing device, while we still think we're in keyboard modality.\n   * @param {Event} e\n   */\n  function onPointerDown(e) {\n    hadKeyboardEvent = false;\n  }\n\n  /**\n   * On `focus`, add the `focus-visible` class to the target if:\n   * - the target received focus as a result of keyboard navigation, or\n   * - the event target is an element that will likely require interaction\n   *   via the keyboard (e.g. a text box)\n   * @param {Event} e\n   */\n  function onFocus(e) {\n    // Prevent IE from focusing the document or HTML element.\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n      addFocusVisibleClass(e.target);\n    }\n  }\n\n  /**\n   * On `blur`, remove the `focus-visible` class from the target.\n   * @param {Event} e\n   */\n  function onBlur(e) {\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (\n      e.target.classList.contains('focus-visible') ||\n      e.target.hasAttribute('data-focus-visible-added')\n    ) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n        hadFocusVisibleRecently = false;\n      }, 100);\n      removeFocusVisibleClass(e.target);\n    }\n  }\n\n  /**\n   * If the user changes tabs, keep track of whether or not the previously\n   * focused element had .focus-visible.\n   * @param {Event} e\n   */\n  function onVisibilityChange(e) {\n    if (document.visibilityState === 'hidden') {\n      // If the tab becomes active again, the browser will handle calling focus\n      // on the element (Safari actually calls it twice).\n      // If this tab change caused a blur on an element with focus-visible,\n      // re-apply the class when the user switches back to the tab.\n      if (hadFocusVisibleRecently) {\n        hadKeyboardEvent = true;\n      }\n      addInitialPointerMoveListeners();\n    }\n  }\n\n  /**\n   * Add a group of listeners to detect usage of any pointing devices.\n   * These listeners will be added when the polyfill first loads, and anytime\n   * the window is blurred, so that they are active when the window regains\n   * focus.\n   */\n  function addInitialPointerMoveListeners() {\n    document.addEventListener('mousemove', onInitialPointerMove);\n    document.addEventListener('mousedown', onInitialPointerMove);\n    document.addEventListener('mouseup', onInitialPointerMove);\n    document.addEventListener('pointermove', onInitialPointerMove);\n    document.addEventListener('pointerdown', onInitialPointerMove);\n    document.addEventListener('pointerup', onInitialPointerMove);\n    document.addEventListener('touchmove', onInitialPointerMove);\n    document.addEventListener('touchstart', onInitialPointerMove);\n    document.addEventListener('touchend', onInitialPointerMove);\n  }\n\n  function removeInitialPointerMoveListeners() {\n    document.removeEventListener('mousemove', onInitialPointerMove);\n    document.removeEventListener('mousedown', onInitialPointerMove);\n    document.removeEventListener('mouseup', onInitialPointerMove);\n    document.removeEventListener('pointermove', onInitialPointerMove);\n    document.removeEventListener('pointerdown', onInitialPointerMove);\n    document.removeEventListener('pointerup', onInitialPointerMove);\n    document.removeEventListener('touchmove', onInitialPointerMove);\n    document.removeEventListener('touchstart', onInitialPointerMove);\n    document.removeEventListener('touchend', onInitialPointerMove);\n  }\n\n  /**\n   * When the polfyill first loads, assume the user is in keyboard modality.\n   * If any event is received from a pointing device (e.g. mouse, pointer,\n   * touch), turn off keyboard modality.\n   * This accounts for situations where focus enters the page from the URL bar.\n   * @param {Event} e\n   */\n  function onInitialPointerMove(e) {\n    // Work around a Safari quirk that fires a mousemove on <html> whenever the\n    // window blurs, even if you're tabbing out of the page. Â¯\\_(ãƒ„)_/Â¯\n    if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {\n      return;\n    }\n\n    hadKeyboardEvent = false;\n    removeInitialPointerMoveListeners();\n  }\n\n  // For some kinds of state, we are interested in changes at the global scope\n  // only. For example, global pointer input, global key presses and global\n  // visibility change should affect the state at every scope:\n  document.addEventListener('keydown', onKeyDown, true);\n  document.addEventListener('mousedown', onPointerDown, true);\n  document.addEventListener('pointerdown', onPointerDown, true);\n  document.addEventListener('touchstart', onPointerDown, true);\n  document.addEventListener('visibilitychange', onVisibilityChange, true);\n\n  addInitialPointerMoveListeners();\n\n  // For focus and blur, we specifically care about state changes in the local\n  // scope. This is because focus / blur events that originate from within a\n  // shadow root are not re-dispatched from the host element if it was already\n  // the active element in its own scope:\n  scope.addEventListener('focus', onFocus, true);\n  scope.addEventListener('blur', onBlur, true);\n\n  // We detect that a node is a ShadowRoot by ensuring that it is a\n  // DocumentFragment and also has a host property. This check covers native\n  // implementation and polyfill implementation transparently. If we only cared\n  // about the native implementation, we could just check if the scope was\n  // an instance of a ShadowRoot.\n  if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {\n    // Since a ShadowRoot is a special kind of DocumentFragment, it does not\n    // have a root element to add a class to. So, we add this attribute to the\n    // host element instead:\n    scope.host.setAttribute('data-js-focus-visible', '');\n  } else if (scope.nodeType === Node.DOCUMENT_NODE) {\n    document.documentElement.classList.add('js-focus-visible');\n    document.documentElement.setAttribute('data-js-focus-visible', '');\n  }\n}\n\n// It is important to wrap all references to global window and document in\n// these checks to support server-side rendering use cases\n// @see https://github.com/WICG/focus-visible/issues/199\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  // Make the polyfill helper globally available. This can be used as a signal\n  // to interested libraries that wish to coordinate with the polyfill for e.g.,\n  // applying the polyfill to a shadow root:\n  window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;\n\n  // Notify interested libraries of the polyfill's presence, in case the\n  // polyfill was loaded lazily:\n  var event;\n\n  try {\n    event = new CustomEvent('focus-visible-polyfill-ready');\n  } catch (error) {\n    // IE11 does not support using CustomEvent as a constructor directly:\n    event = document.createEvent('CustomEvent');\n    event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});\n  }\n\n  window.dispatchEvent(event);\n}\n","//     mp3-parser/lib v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") { return createModule(exports); }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3ParserLib = globalObject.mp3ParserLib;\n    createModule(globalObject.mp3ParserLib = {\n        noConflict: function () {\n            var lib = globalObject.mp3ParserLib;\n            globalObject.mp3ParserLib = previousMp3ParserLib;\n            return (this.noConflict = function () { return lib; }).call();\n        }\n    });\n}(this, function (lib) {\n    \"use strict\";\n\n    // Produce octet's binary representation as a string\n    var octetToBinRep = (function () {\n        var b = []; // The binary representation\n        return function (octet) {\n            b[0] = ((octet & 128) === 128 ? \"1\" : \"0\");\n            b[1] = ((octet & 64)  === 64  ? \"1\" : \"0\");\n            b[2] = ((octet & 32)  === 32  ? \"1\" : \"0\");\n            b[3] = ((octet & 16)  === 16  ? \"1\" : \"0\");\n            b[4] = ((octet & 8)   === 8   ? \"1\" : \"0\");\n            b[5] = ((octet & 4)   === 4   ? \"1\" : \"0\");\n            b[6] = ((octet & 2)   === 2   ? \"1\" : \"0\");\n            b[7] = ((octet & 1)   === 1   ? \"1\" : \"0\");\n            return b.join(\"\");\n        };\n    }());\n\n    // Get the number of bytes in a frame given its `bitrate`, `samplingRate` and `padding`.\n    //  Based on [magic formula](http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm)\n    lib.getFrameByteLength = function (kbitrate, samplingRate, padding, mpegVersion, layerVersion) {\n        var sampleLength = lib.sampleLengthMap[mpegVersion][layerVersion];\n        var paddingSize = padding ? (layerVersion === \"11\" ? 4 : 1) : 0;\n        var byteRate = kbitrate * 1000 / 8;\n        return Math.floor((sampleLength * byteRate / samplingRate) + paddingSize);\n    };\n\n    lib.getXingOffset = function (mpegVersion, channelMode) {\n        var mono = channelMode === \"11\";\n        if (mpegVersion === \"11\") { // mpeg1\n            return mono ? 21 : 36;\n        } else {\n            return mono ? 13 : 21;\n        }\n    };\n\n    //\n    lib.v1l1Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 64,\n        \"0011\": 96,\n        \"0100\": 128,\n        \"0101\": 160,\n        \"0110\": 192,\n        \"0111\": 224,\n        \"1000\": 256,\n        \"1001\": 288,\n        \"1010\": 320,\n        \"1011\": 352,\n        \"1100\": 384,\n        \"1101\": 416,\n        \"1110\": 448,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v1l2Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 48,\n        \"0011\": 56,\n        \"0100\": 64,\n        \"0101\": 80,\n        \"0110\": 96,\n        \"0111\": 112,\n        \"1000\": 128,\n        \"1001\": 160,\n        \"1010\": 192,\n        \"1011\": 224,\n        \"1100\": 256,\n        \"1101\": 320,\n        \"1110\": 384,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v1l3Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 40,\n        \"0011\": 48,\n        \"0100\": 56,\n        \"0101\": 64,\n        \"0110\": 80,\n        \"0111\": 96,\n        \"1000\": 112,\n        \"1001\": 128,\n        \"1010\": 160,\n        \"1011\": 192,\n        \"1100\": 224,\n        \"1101\": 256,\n        \"1110\": 320,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v2l1Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 32,\n        \"0010\": 48,\n        \"0011\": 56,\n        \"0100\": 64,\n        \"0101\": 80,\n        \"0110\": 96,\n        \"0111\": 112,\n        \"1000\": 128,\n        \"1001\": 144,\n        \"1010\": 160,\n        \"1011\": 176,\n        \"1100\": 192,\n        \"1101\": 224,\n        \"1110\": 256,\n        \"1111\": \"bad\"\n    };\n\n    //\n    lib.v2l2Bitrates = {\n        \"0000\": \"free\",\n        \"0001\": 8,\n        \"0010\": 16,\n        \"0011\": 24,\n        \"0100\": 32,\n        \"0101\": 40,\n        \"0110\": 48,\n        \"0111\": 56,\n        \"1000\": 64,\n        \"1001\": 80,\n        \"1010\": 96,\n        \"1011\": 112,\n        \"1100\": 128,\n        \"1101\": 144,\n        \"1110\": 160,\n        \"1111\": \"bad\"\n    };\n    lib.v2l3Bitrates = lib.v2l2Bitrates;\n\n    //\n    lib.v1SamplingRates = {\n        \"00\": 44100,\n        \"01\": 48000,\n        \"10\": 32000,\n        \"11\": \"reserved\"\n    };\n\n    //\n    lib.v2SamplingRates = {\n        \"00\": 22050,\n        \"01\": 24000,\n        \"10\": 16000,\n        \"11\": \"reserved\"\n    };\n\n    //\n    lib.v25SamplingRates = {\n        \"00\": 11025,\n        \"01\": 12000,\n        \"10\": 8000,\n        \"11\": \"reserved\"\n    };\n\n    //\n    lib.channelModes = {\n        \"00\": \"Stereo\",\n        \"01\": \"Joint stereo (Stereo)\",\n        \"10\": \"Dual channel (Stereo)\",\n        \"11\": \"Single channel (Mono)\"\n    };\n\n    //\n    lib.mpegVersionDescription = {\n        \"00\": \"MPEG Version 2.5 (unofficial)\",\n        \"01\": \"reserved\",\n        \"10\": \"MPEG Version 2 (ISO/IEC 13818-3)\",\n        \"11\": \"MPEG Version 1 (ISO/IEC 11172-3)\"\n    };\n\n    //\n    lib.layerDescription = {\n        \"00\": \"reserved\",\n        \"01\": \"Layer III\",\n        \"10\": \"Layer II\",\n        \"11\": \"Layer I\"\n    };\n\n    //\n    lib.bitrateMap = {\n        \"11\": {\n            \"01\": lib.v1l3Bitrates,\n            \"10\": lib.v1l2Bitrates,\n            \"11\": lib.v1l1Bitrates\n        },\n        \"10\": {\n            \"01\": lib.v2l3Bitrates,\n            \"10\": lib.v2l2Bitrates,\n            \"11\": lib.v2l1Bitrates\n        }\n    };\n\n    //\n    lib.samplingRateMap = {\n        \"00\": lib.v25SamplingRates,\n        \"10\": lib.v2SamplingRates,\n        \"11\": lib.v1SamplingRates\n    };\n\n    //\n    lib.v1SampleLengths = {\n        \"01\": 1152,\n        \"10\": 1152,\n        \"11\": 384\n    };\n\n    //\n    lib.v2SampleLengths = {\n        \"01\": 576,\n        \"10\": 1152,\n        \"11\": 384\n    };\n\n    //\n    lib.sampleLengthMap = {\n        \"01\": lib.v2SampleLengths,\n        \"10\": lib.v2SampleLengths,\n        \"11\": lib.v1SampleLengths\n    };\n\n    // Convert the given string `str` to an array of words (octet pairs). If all characters in the\n    //  given string are within the ISO/IEC 8859-1 subset then the returned array may safely be\n    //  interpreted as an array of values in the [0, 255] range, where each value requires a single\n    //  octet to be represented. Otherwise it should be interpreted as an array of values in the\n    //  [0, 65.535] range, where each value requires a word (octet pair) to be represented.\n    //\n    // Not meant to be used with UTF-16 strings that contain chars outside the BMP. See\n    //  [charCodeAt on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)\n    lib.wordSeqFromStr = function (str) {\n        for (var i = str.length - 1, seq = []; i >= 0; --i) {\n            seq[i] = str.charCodeAt(i);\n        }\n        return seq;\n    };\n\n    // Common character sequences converted to byte arrays\n    lib.seq = {\n        id3: lib.wordSeqFromStr(\"ID3\"),\n        xing: lib.wordSeqFromStr(\"Xing\"),\n        info: lib.wordSeqFromStr(\"Info\")\n    };\n\n    // A handy no-op to reuse\n    lib.noOp = function () {};\n\n    // Decode a [synchsafe](http://en.wikipedia.org/wiki/Synchsafe) value. Synchsafes are used in\n    //  ID3 tags, instead of regular ints, to avoid the unintended introduction of bogus\n    //  frame-syncs. Note that the spec requires that syncsafe be always stored in big-endian order\n    //  (Implementation shamefully lifted from relevant wikipedia article)\n    lib.unsynchsafe = function (value) {\n        var out = 0;\n        var mask = 0x7F000000;\n\n        while (mask) {\n            out >>= 1;\n            out |= value & mask;\n            mask >>= 8;\n        }\n\n        return out;\n    };\n\n    // Get a value indicating whether given DataView `view` contains the `seq` sequence (array\n    //  of octets) at `offset` index. Note that no check is performed for the adequate length of\n    //  given view as this should be carried out by the caller\n    lib.isSeq = function (seq, view, offset) {\n        for (var i = seq.length - 1; i >= 0; i--) {\n            if (seq[i] !== view.getUint8(offset + i)) { return false; }\n        }\n        return true;\n    };\n\n    // Get a value indicating whether given DataView `view` contains the `str` string\n    //  at `offset` index. The view is parsed as an array of 8bit single-byte coded characters\n    //  (i.e. ISO/IEC 8859-1, _non_ Unicode). Will return the string itself if it does, false\n    //  otherwise. Note that no check is performed for the adequate length of given view as\n    //  this should be carried out be the caller as part of the section-parsing process\n    /*\n    isStr = function (str, view, offset) {\n        return isSeq(lib.wordSeqFromStr(str), view, offset) ? str : false;\n    };\n    */\n\n    // Locate first occurrence of sequence `seq` (an array of octets) in DataView `view`.\n    //  Search starts at given `offset` and ends after `length` octets. Will return the\n    //  absolute offset of sequence if found, -1 otherwise\n    lib.locateSeq = function (seq, view, offset, length) {\n        for (var i = 0, l = length - seq.length + 1; i < l; ++i) {\n            if (lib.isSeq(seq, view, offset + i)) { return offset + i; }\n        }\n        return -1;\n    };\n\n    lib.locateStrTrm = {\n        // Locate the first occurrence of non-Unicode null-terminator (i.e. a single zeroed-out\n        //  octet) in DataView `view`. Search starts at given `offset` and ends after `length`\n        //  octets. Will return the absolute offset of sequence if found, -1 otherwise\n        iso: function (view, offset, length) {\n            return lib.locateSeq([0], view, offset, length);\n        },\n\n        // Locate the first occurrence of Unicode null-terminator (i.e. a sequence of two\n        //  zeroed-out octets) in DataView `view`. Search starts at given `offset` and ends after\n        //  `length` octets. Will return the absolute offset of sequence if found, -1 otherwise\n        ucs: function (view, offset, length) {\n            var trmOffset = lib.locateSeq([0, 0], view, offset, length);\n            if (trmOffset === -1) { return -1; }\n            if ((trmOffset - offset) % 2 !== 0) { ++trmOffset; }\n            return trmOffset;\n        }\n    };\n\n    lib.readStr = {\n        // Parse DataView `view` begining at `offset` index and return a string built from\n        //  `length` octets. The view is parsed as an array of 8bit single-byte coded characters\n        //  (i.e. ISO/IEC 8859-1, _non_ Unicode). Will essentially return the string comprised of\n        //  octets [offset, offset + length). Note that no check is performed for the adequate\n        //  length of given view as this should be carried out be the caller as part of the\n        //  section-parsing process\n        iso: function (view, offset, length) {\n            return String.fromCharCode.apply(null, new Uint8Array(view.buffer, offset, length));\n        },\n\n        // UCS-2 (ISO/IEC 10646-1:1993, UCS-2) version of `readStr`. UCS-2 is the fixed-width\n        //  two-byte subset of Unicode that can only express values inside the Basic Multilingual\n        //  Plane (BMP). Note that this method is generally unsuitable for parsing non-trivial\n        //  UTF-16 strings which may contain surrogate pairs. [This is only marginally related\n        //  though as, according to ID3v2, all Unicode strings should be UCS-2.] Further info:\n        //\n        //  * [How to convert ArrayBuffer to and from String](http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String)\n        //  * [The encoding spec](http://encoding.spec.whatwg.org/)\n        //  * [stringencoding shim](https://code.google.com/p/stringencoding/)\n        //\n        // About the BOM: The current implementation will check for and remove the leading BOM from\n        //  the given view to avoid invisible characters that mess up the resulting strings. MDN's\n        //  documentation for [fromCharCode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)\n        //  suggests that it can correctly convert UCS-2 buffers to strings. And indeed, tests\n        //  performed with UCS-2 LE encoded frames indicate that it does. However, no tests have\n        //  been made for UCS-2 BE. (Kid3, the ID3v2 Tag generator used for tests at the time of\n        //  this writing, goes totally weird when switched to BE)\n        ucs: function (view, offset, length) {\n            // Tweak offset to remove the BOM (LE: FF FE / BE: FE FF)\n            if (view.getUint16(offset) === 0xFFFE || view.getUint16(offset) === 0xFEFF) {\n                offset += 2;\n                length -= 2;\n            }\n\n            var buffer = view.buffer;\n\n            // When offset happens to be an even number of octets, the array-buffer may be wrapped\n            //  in a Uint16Array. In the event that it's _not_, an actual copy has to be made\n            // (Note that Node <= 0.8 as well as IE <= 10 lack an ArrayBuffer#slice. TODO: shim it)\n            if (offset % 2 === 1) {\n                buffer = buffer.slice(offset, offset + length);\n                offset = 0;\n            }\n\n            return String.fromCharCode.apply(null, new Uint16Array(buffer, offset, length / 2));\n        }\n    };\n\n    lib.readTrmStr = {\n        // Similar to `readStr.iso` but will check for a null-terminator determining the end of the\n        //  string. The returned string will be of _at most_ `length` octets\n        iso: function (view, offset, length) {\n            var trmOffset = lib.locateStrTrm.iso(view, offset, length);\n            if (trmOffset !== -1) { length = trmOffset - offset; }\n            return lib.readStr.iso(view, offset, length);\n        },\n\n        // Similar to `readStr.ucs` but will check for a null-terminator determining the end of the\n        //  string. The returned string will be of _at most_ `length` octets\n        ucs: function (view, offset, length) {\n            var trmOffset = lib.locateStrTrm.ucs(view, offset, length);\n            if (trmOffset !== -1) { length = trmOffset - offset; }\n            return lib.readStr.ucs(view, offset, length);\n        }\n    };\n\n    // ### Read a Frame Header\n    //\n    // Read header of frame located at `offset` of DataView `view`. Returns null in the event\n    //  that no frame header is found at `offset`\n    lib.readFrameHeader = function (view, offset) {\n        offset || (offset = 0);\n\n        // There should be more than 4 octets ahead\n        if (view.byteLength - offset <= 4) { return null; }\n\n        // Header's first (out of four) octet: `11111111`: Frame sync (all bits must be set)\n        var b1 = view.getUint8(offset);\n        if (b1 !== 255) { return null; }\n\n        // Header's second (out of four) octet: `111xxxxx`\n        //\n        // * `111.....`: Rest of frame sync (all bits must be set)\n        // * `...BB...`: MPEG Audio version ID (11 -> MPEG Version 1 (ISO/IEC 11172-3))\n        // * `.....CC.`: Layer description (01 -> Layer III)\n        // * `.......1`: Protection bit (1 = Not protected)\n\n        // Require the three most significant bits to be `111` (>= 224)\n        var b2 = view.getUint8(offset + 1);\n        if (b2 < 224) { return null; }\n\n        var mpegVersion = octetToBinRep(b2).substr(3, 2);\n        var layerVersion = octetToBinRep(b2).substr(5, 2);\n\n        //\n        var header = {\n            _section: { type: \"frameHeader\", byteLength: 4, offset: offset },\n            mpegAudioVersionBits: mpegVersion,\n            mpegAudioVersion: lib.mpegVersionDescription[mpegVersion],\n            layerDescriptionBits: layerVersion,\n            layerDescription: lib.layerDescription[layerVersion],\n            isProtected: b2 & 1, // Just check if last bit is set\n        };\n        header.protectionBit = header.isProtected ? \"1\" : \"0\";\n\n        if (header.mpegAudioVersion === \"reserved\") { return null; }\n        if (header.layerDescription === \"reserved\") { return null; }\n\n        // Header's third (out of four) octet: `EEEEFFGH`\n        //\n        // * `EEEE....`: Bitrate index. 1111 is invalid, everything else is accepted\n        // * `....FF..`: Sampling rate, 00=44100, 01=48000, 10=32000, 11=reserved\n        // * `......G.`: Padding bit, 0=frame not padded, 1=frame padded\n        // * `.......H`: Private bit. This is informative\n        var b3 = view.getUint8(offset + 2);\n        b3 = octetToBinRep(b3);\n        header.bitrateBits = b3.substr(0, 4);\n        header.bitrate = lib.bitrateMap[mpegVersion][layerVersion][header.bitrateBits];\n        if (header.bitrate === \"bad\") { return null; }\n\n        header.samplingRateBits = b3.substr(4, 2);\n        header.samplingRate = lib.samplingRateMap[mpegVersion][header.samplingRateBits];\n        if (header.samplingRate === \"reserved\") { return null; }\n\n        header.frameIsPaddedBit = b3.substr(6, 1);\n        header.frameIsPadded = header.frameIsPaddedBit === \"1\";\n        header.framePadding = header.frameIsPadded ? 1 : 0;\n\n        header.privateBit = b3.substr(7, 1);\n\n        // Header's fourth (out of four) octet: `IIJJKLMM`\n        //\n        // * `II......`: Channel mode\n        // * `..JJ....`: Mode extension (only if joint stereo)\n        // * `....K...`: Copyright\n        // * `.....L..`: Original\n        // * `......MM`: Emphasis\n        var b4 = view.getUint8(offset + 3);\n        header.channelModeBits = octetToBinRep(b4).substr(0, 2);\n        header.channelMode = lib.channelModes[header.channelModeBits];\n\n        return header;\n    };\n\n    // ### Read a Frame\n    //\n    // Read frame located at `offset` of DataView `view`. Will acquire the frame header (see\n    //  `readFrameHeader`) plus some basic information about the frame - notably the frame's length\n    //  in bytes. If `requireNextFrame` is set, the presence of a _next_ valid frame will be\n    //  required for _this_ frame to be regarded as valid. Returns null in the event that no frame\n    //  is found at `offset`\n    lib.readFrame = function (view, offset, requireNextFrame) {\n        offset || (offset = 0);\n\n        var frame = {\n            _section: { type: \"frame\", offset: offset },\n            header: lib.readFrameHeader(view, offset)\n        };\n\n        var head = frame.header; // Convenience shortcut\n\n        // Frame should always begin with a valid header\n        if (!head) { return null; }\n\n        frame._section.sampleLength =\n            lib.sampleLengthMap[head.mpegAudioVersionBits][head.layerDescriptionBits];\n\n        //\n        frame._section.byteLength = lib.getFrameByteLength(head.bitrate, head.samplingRate,\n            head.framePadding, head.mpegAudioVersionBits, head.layerDescriptionBits);\n        frame._section.nextFrameIndex = offset + frame._section.byteLength;\n\n        // No \"Xing\" or \"Info\" identifier should be present - this would indicate that this\n        //  is in fact a Xing tag masquerading as a frame\n        var xingOffset = lib.getXingOffset(head.mpegAudioVersionBits, head.channelModeBits);\n        if (lib.isSeq(lib.seq.xing, view, offset + xingOffset) ||\n            lib.isSeq(lib.seq.info, view, offset + xingOffset)) {\n            return null;\n        }\n\n        // If a next frame is required then the data at `frame._section.nextFrameIndex` should be\n        //  a valid frame header\n        if (requireNextFrame && !lib.readFrameHeader(view, frame._section.nextFrameIndex)) {\n            return null;\n        }\n\n        return frame;\n    };\n}));\n","//     mp3-parser/id3v2 v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false, require:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\", \"./lib\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") {\n        return createModule(exports, require(\"./lib\"));\n    }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3Id3v2Parser = globalObject.mp3Id3v2Parser;\n    createModule(globalObject.mp3Id3v2Parser = {\n        noConflict: function () {\n            var mp3Id3v2Parser = globalObject.mp3Id3v2Parser;\n            globalObject.mp3Id3v2Parser = previousMp3Id3v2Parser;\n            return (this.noConflict = function () { return mp3Id3v2Parser; }).call();\n        }\n    }, globalObject.mp3ParserLib);\n}(this, function (mp3Id3v2Parser, lib) {\n    \"use strict\";\n\n    //\n    var id3v2TagFrameNames = {\n        AENC: \"Audio encryption\",\n        APIC: \"Attached picture\",\n        CHAP: \"Chapter\",\n        COMM: \"Comments\",\n        COMR: \"Commercial frame\",\n        ENCR: \"Encryption method registration\",\n        EQUA: \"Equalization\",\n        ETCO: \"Event timing codes\",\n        GEOB: \"General encapsulated object\",\n        GRID: \"Group identification registration\",\n        IPLS: \"Involved people list\",\n        LINK: \"Linked information\",\n        MCDI: \"Music CD identifier\",\n        MLLT: \"MPEG location lookup table\",\n        OWNE: \"Ownership frame\",\n        PRIV: \"Private frame\",\n        PCNT: \"Play counter\",\n        POPM: \"Popularimeter\",\n        POSS: \"Position synchronisation frame\",\n        RBUF: \"Recommended buffer size\",\n        RVAD: \"Relative volume adjustment\",\n        RVRB: \"Reverb\",\n        SYLT: \"Synchronized lyric/text\",\n        SYTC: \"Synchronized tempo codes\",\n        TALB: \"Album/Movie/Show title\",\n        TBPM: \"BPM (beats per minute)\",\n        TCOM: \"Composer\",\n        TCON: \"Content type\",\n        TCOP: \"Copyright message\",\n        TDAT: \"Date\",\n        TDLY: \"Playlist delay\",\n        TENC: \"Encoded by\",\n        TEXT: \"Lyricist/Text writer\",\n        TFLT: \"File type\",\n        TIME: \"Time\",\n        TIT1: \"Content group description\",\n        TIT2: \"Title/songname/content description\",\n        TIT3: \"Subtitle/Description refinement\",\n        TKEY: \"Initial key\",\n        TLAN: \"Language(s)\",\n        TLEN: \"Length\",\n        TMED: \"Media type\",\n        TOAL: \"Original album/movie/show title\",\n        TOFN: \"Original filename\",\n        TOLY: \"Original lyricist(s)/text writer(s)\",\n        TOPE: \"Original artist(s)/performer(s)\",\n        TORY: \"Original release year\",\n        TOWN: \"File owner/licensee\",\n        TPE1: \"Lead performer(s)/Soloist(s)\",\n        TPE2: \"Band/orchestra/accompaniment\",\n        TPE3: \"Conductor/performer refinement\",\n        TPE4: \"Interpreted, remixed, or otherwise modified by\",\n        TPOS: \"Part of a set\",\n        TPUB: \"Publisher\",\n        TRCK: \"Track number/Position in set\",\n        TRDA: \"Recording dates\",\n        TRSN: \"Internet radio station name\",\n        TRSO: \"Internet radio station owner\",\n        TSIZ: \"Size\",\n        TSRC: \"ISRC (international standard recording code)\",\n        TSSE: \"Software/Hardware and settings used for encoding\",\n        TYER: \"Year\",\n        TXXX: \"User defined text information frame\",\n        UFID: \"Unique file identifier\",\n        USER: \"Terms of use\",\n        USLT: \"Unsychronized lyric/text transcription\",\n        WCOM: \"Commercial information\",\n        WCOP: \"Copyright/Legal information\",\n        WOAF: \"Official audio file webpage\",\n        WOAR: \"Official artist/performer webpage\",\n        WOAS: \"Official audio source webpage\",\n        WORS: \"Official internet radio station homepage\",\n        WPAY: \"Payment\",\n        WPUB: \"Publishers official webpage\",\n        WXXX: \"User defined URL link frame\"\n    };\n\n    //\n    var readFrameContent = {};\n\n    // Read the content of a\n    //  [text-information frame](http://id3.org/id3v2.3.0#Text_information_frames). These are\n    //  common and contain info such as artist and album. There may only be one text info frame\n    //  of its kind in a tag. If the textstring is followed by a termination (00) all the\n    //  following information should be ignored and not be displayed. All text frame\n    //  identifiers begin with \"T\". Only text frame identifiers begin with \"T\", with the\n    //  exception of the \"TXXX\" frame\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Information: a text string according to encoding\n    readFrameContent.T = function (view, offset, length) {\n        var content = { encoding: view.getUint8(offset) };\n        content.value = lib.readStr[content.encoding === 0 ? \"iso\" : \"ucs\"](\n            view, offset + 1, length - 1);\n        return content;\n    };\n\n    // Read the content of a\n    //  [user-defined text-information frame](http://id3.org/id3v2.3.0#User_defined_text_information_frame).\n    //  Intended for one-string text information concerning the audiofile in a similar way to\n    //  the other \"T\"-frames. The frame body consists of a description of the string,\n    //  represented as a terminated string, followed by the actual string. There may be more\n    //  than one \"TXXX\" frame in each tag, but only one with the same description\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Description: a text string according to encoding (followed by 00 (00))\n    // * Value:       a text string according to encoding\n    readFrameContent.TXXX = function  (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + null term. = at least 2 octets\n        if (length < 2) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and content beginning (description field)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 1;\n\n        // Locate the the null terminator seperating description and URL\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read description and value data into content\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\n        content.value = lib.readStr[enc](view, offsetTrm, offset + length - offsetTrm);\n\n        return content;\n    };\n\n    // Read the content of a\n    //  [URL-link frame](http://id3.org/id3v2.3.0#URL_link_frames). There may only be one\n    //  URL link frame of its kind in a tag, except when stated otherwise in the frame\n    //  description. If the textstring is followed by a termination (00) all the following\n    //  information should be ignored and not be displayed. All URL link frame identifiers\n    //  begins with \"W\". Only URL link frame identifiers begins with \"W\"\n    //\n    // * URL: a text string\n    readFrameContent.W = function (view, offset, length) {\n        return { value: lib.readStr.iso(view, offset, length) };\n    };\n\n    // Read the content of a\n    //  [user-defined URL-link frame](http://id3.org/id3v2.3.0#User_defined_URL_link_frame).\n    //  Intended for URL links concerning the audiofile in a similar way to the other\n    //  \"W\"-frames. The frame body consists of a description of the string, represented as a\n    //  terminated string, followed by the actual URL. The URL is always encoded with\n    //  ISO-8859-1. There may be more than one \"WXXX\" frame in each tag, but only one with the\n    //  same description\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Description: a text string according to encoding (followed by 00 (00))\n    // * URL:         a text string\n    readFrameContent.WXXX = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + null term. = at least 2 octets\n        if (length < 2) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and content beginning (description field)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 1;\n\n        // Locate the the null terminator seperating description and URL\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read description and value data into content\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\n        content.value = lib.readStr.iso(view, offsetTrm, offset + length - offsetTrm);\n\n        return content;\n    };\n\n    // Read the content of a [comment frame](http://id3.org/id3v2.3.0#Comments).\n    //  Intended for any kind of full text information that does not fit in any other frame.\n    //  Consists of a frame header followed by encoding, language and content descriptors and\n    //  ends with the actual comment as a text string. Newline characters are allowed in the\n    //  comment text string. There may be more than one comment frame in each tag, but only one\n    //  with the same language and content descriptor. [Note that the structure of comment\n    //  frames is identical to that of USLT frames - `readFrameContentComm` will handle both.]\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Language:    3 digit (octet) lang-code (ISO-639-2)\n    // * Short descr: a text string according to encoding (followed by 00 (00))\n    // * Actual text: a text string according to encoding\n    readFrameContent.COMM = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + language + null term. = at least 5 octets\n        if (length < 5) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and content beggining (short description field)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 4;\n\n        // Read the language field - 3 octets at most\n        content.language = lib.readTrmStr.iso(view, offset + 1, 3);\n\n        // Locate the the null terminator seperating description and text\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read short description and text data into content\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\n        content.text = lib.readStr[enc](view, offsetTrm, offset + length - offsetTrm);\n\n        return content;\n    };\n\n    // Read the content of a\n    //  [unique file identifier frame](http://id3.org/id3v2.3.0#Unique_file_identifier). Allows\n    //  identification of the audio file by means of some database that may contain more\n    //  information relevant to the content. Begins with a URL containing an email address, or\n    //  a link to a location where an email address can be found that belongs to the\n    //  organisation responsible for this specific database implementation. The 'Owner\n    //  identifier' must be non-empty (more than just a termination) and is followed by the\n    //  actual identifier, which may be up to 64 bytes. There may be more than one \"UFID\" frame\n    //  in a tag, but only one with the same 'Owner identifier'. Note that this frame is very\n    //  similar to the \"PRIV\" frame\n    //\n    // * Owner identifier: a text string (followed by 00)\n    // * Identifier:       up to 64 bytes of binary data\n    readFrameContent.UFID = function (view, offset, length) {\n        // Read up to the first null terminator to get the owner-identifier\n        var ownerIdentifier = lib.readTrmStr.iso(view, offset, length);\n\n        // Figure out the identifier based on frame length vs owner-identifier length\n        var identifier = new DataView(view.buffer, offset + ownerIdentifier.length + 1,\n            length - ownerIdentifier.length - 1);\n\n        return { ownerIdentifier: ownerIdentifier, identifier: identifier };\n    };\n\n    // Read the content of an\n    //  [involved people list frame](http://id3.org/id3v2.3.0#Involved_people_list). Contains\n    //  names of those involved - those contributing to the audio file - and how they were\n    //  involved. The body simply contains the first 'involvement' as a terminated string, directly\n    //  followed by the first 'involvee' as a terminated string, followed by a second terminated\n    //  involvement string and so on. However, in the current implementation the frame's content is\n    //  parsed as a collection of strings without any semantics attached. There may only be one\n    //  \"IPLS\" frame in each tag\n    //\n    // * Encoding:            a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * People list strings: a series of strings, e.g. string 00 (00) string 00 (00) ..\n    readFrameContent.IPLS = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset), values: [] };\n\n        // Encoding and content beginning (people list - specifically, first 'involvement' string)\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg = offset + 1;\n\n        // Index of null-terminator found within people list (seperates involvement / involvee)\n        var offsetNextStrTrm;\n\n        while (offsetBeg < offset + length) {\n            // We expect all strings within the people list to be null terminated ..\n            offsetNextStrTrm = lib.locateStrTrm[enc](view, offsetBeg, length - (offsetBeg - offset));\n\n            // .. except _perhaps_ the last one. In this case fix the offset at the frame's end\n            if (offsetNextStrTrm === -1) {\n                offsetNextStrTrm = offset + length;\n            }\n\n            content.values.push(lib.readStr[enc](view, offsetBeg, offsetNextStrTrm - offsetBeg));\n            offsetBeg = offsetNextStrTrm + (enc === \"ucs\" ? 2 : 1);\n        }\n\n        return content;\n    };\n\n    // Read the content of a [terms of use frame](http://id3.org/id3v2.3.0#Terms_of_use_frame).\n    //  Contains a description of the terms of use and ownership of the file. Newlines are\n    //  allowed in the text. There may only be one \"USER\" frame in a tag.\n    //\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * Language:    3 digit (octet) lang-code (ISO-639-2)\n    // * Actual text: a text string according to encoding\n    readFrameContent.USER = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + language + null term. = at least 5 octets\n        if (length < 5) {\n            return content; // Inadequate length!\n        }\n\n        // Read the language field - 3 octets at most\n        content.language = lib.readTrmStr.iso(view, offset + 1, 3);\n\n        // Read the text field\n        var offsetBeg = offset + 4;\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        content.text = lib.readStr[enc](view, offsetBeg, offset + length - offsetBeg);\n\n        return content;\n    };\n\n    // Read the content of a\n    //  [private frame](http://id3.org/id3v2.3.0#Private_frame). Contains binary data that does\n    //  no fit into the other frames. Begins with a URL containing an email address, or\n    //  a link to a location where an email address can be found. The 'Owner identifier' must\n    //  be non-empty (more than just a termination) and is followed by the actual data. There\n    //  may be more than one \"PRIV\" frame in a tag, but only with different contents. Note that\n    //  this frame is very similar to the \"UFID\" frame\n    //\n    // * Owner identifier: a text string (followed by 00)\n    // * private data:     binary data (of unbounded length)\n    readFrameContent.PRIV = function (view, offset, length) {\n        // Read up to the first null terminator to get the owner-identifier\n        var ownerIdentifier = lib.readTrmStr.iso(view, offset, length);\n\n        // Figure out the private data based on frame length vs owner-identifier length\n        var privateData = new DataView(view.buffer, offset + ownerIdentifier.length + 1,\n            length - ownerIdentifier.length - 1);\n\n        return { ownerIdentifier: ownerIdentifier, privateData: privateData };\n    };\n\n    // Read the content of a [play counter](http://id3.org/id3v2.3.0#Play_counter). A counter\n    //  of the number of times a file has been played. There may only be one \"PCNT\" frame in a\n    //  tag. [According to the standard, \"When the counter reaches all one's, one byte is\n    //  inserted in front of the counter thus making the counter eight bits bigger.\" This is\n    //  not currently taken into account]\n    //\n    // * Counter: 4 octets (at least ..)\n    readFrameContent.PCNT = function (view, offset, length) {\n        // The counter must be at least 4 octets long to begin with\n        if (length < 4) {\n            return {}; // Inadequate length!\n        }\n\n        // Assume the counter is always exactly 4 octets ..\n        return { counter: view.getUint32(offset) };\n    };\n\n    // Read the content of a [popularimeter](http://id3.org/id3v2.3.0#Popularimeter). Intended\n    //  as a measure for the file's popularity, it contains a user's email address, one rating\n    //  octet and a four octer play counter, intended to be increased with one for every time\n    //  the file is played. If no personal counter is wanted it may be omitted. [As is the case\n    //  for the \"PCNT\" frame, according to the standard, \"When the counter reaches all one's,\n    //  one byte is inserted in front of the counter thus making the counter eight bits\n    //  bigger.\" This is not currently taken into account]. There may be more than one \"POPM\"\n    //  frame in each tag, but only one with the same email address\n    //\n    // * Email to user: a text string (followed by 00)\n    // * Rating:        a single octet, values in 0-255 (0 = unknown, 1 = worst, 255 = best)\n    // * Counter:       4 octets (at least ..)\n    readFrameContent.POPM = function (view, offset, length) {\n        var content = {\n                email: lib.readTrmStr.iso(view, offset, length)\n            };\n\n        // rating offset\n        offset += content.email.length + 1;\n\n        // email str term + rating + counter = at least 6 octets\n        if (length < 6) {\n            return content; // Inadequate length!\n        }\n\n        content.rating = view.getUint8(offset);\n\n        // Assume the counter is always exactly 4 octets ..\n        content.counter = view.getUint32(offset + 1);\n\n        return content;\n    };\n\n    // Read the content of an [attached picture](http://id3.org/id3v2.3.0#Attached_picture).\n    //  Contains a picture directly related to the audio file. In the event that the MIME media\n    //  type name is omitted, \"image/\" will be implied. The description has a maximum length of\n    //  64 characters, but may be empty. There may be several pictures attached to one file,\n    //  each in their individual \"APIC\" frame, but only one with the same content descriptor.\n    //  There may only be one picture with the picture type declared as picture type $01 and\n    //  $02 respectively.\n    //\n    // * Encoding:     a single octet where 0 = ISO-8859-1, 1 = UCS-2\n    // * MIME Type:    a text string (followed by 00) - MIME type and subtype of image\n    // * Picture type: a single octet, values in 0-255: a type-id as given by the standard\n    // * Description:  a text string according to encoding (followed by 00 (00))\n    // * Picture data: binary data (of unbounded length)\n    readFrameContent.APIC = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Encoding + MIME type string term + pic type octet + descr. string term = min 4 octets\n        if (length < 4) {\n            return content; // Inadequate length!\n        }\n\n        // Encoding and offsets of content beginning / null-terminator\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\n        var offsetBeg, offsetTrm;\n\n        // Locate the the null terminator seperating MIME type and picture type\n        offsetBeg = offset + 1; // After the encoding octet\n        offsetTrm = lib.locateStrTrm.iso(view, offsetBeg, length - 1);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read MIME type\n        content.mimeType = lib.readStr.iso(view, offsetBeg, offsetTrm - offsetBeg);\n\n        // Read picture type\n        offsetBeg = offsetTrm + 1;\n        content.pictureType = view.getUint8(offsetBeg);\n\n        // Locate the the null terminator seperating description and picture data\n        offsetBeg += 1;\n        offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, offset + length - offsetBeg);\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read description\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\n\n        // Read picture data\n        offsetBeg = offsetTrm + (enc === \"ucs\" ? 2 : 1);\n        content.pictureData = new DataView(view.buffer, offsetBeg, offset + length - offsetBeg);\n\n        return content;\n    };\n\n    // Read the chapter tag according to the ID3v2 Chapter Frame Addendum (http://id3.org/id3v2-chapters-1.0)\n    //  The frame contains subframes, typically TIT2, and possibly additional frames\n    //\n    // * Id:            string identifier of the chapter\n    // * Start time:    4 octets specifying the start of the chapter in milliseconds\n    // * End time:      4 octets specifying the end of the chapter in milliseconds\n    // * Start offset:  4 octets specifying the start of the chapter in bytes\n    // * End offset:    4 octets specifying the end of the chapter in bytes\n    // * Frames:        nested id3v2 frames\n    readFrameContent.CHAP = function (view, offset, length) {\n        // The content to be returned\n        var content = { encoding: view.getUint8(offset) };\n\n        // Locate the the null terminator between id and start time\n        var offsetTrm = lib.locateStrTrm.iso(view, offset, length - 1);\n\n        if (offsetTrm === -1) {\n            return content; // Not found!\n        }\n\n        // Read id\n        content.id = lib.readStr.iso(view, offset, offsetTrm - offset);\n\n        // Read start time\n        content.startTime = view.getUint32(offsetTrm + 1);\n\n        // Read end time\n        content.endTime = view.getUint32(offsetTrm + 5);\n\n        // Read start offset\n        content.startOffset = view.getUint32(offsetTrm + 9);\n\n        // Read end offset\n        content.endOffset = view.getUint32(offsetTrm + 13);\n\n        var offsetSubFrames = offsetTrm + 17;\n        content.frames = [];\n        while (offsetSubFrames < offset + length) {\n            var subFrame = mp3Id3v2Parser.readId3v2TagFrame(view, offsetSubFrames);\n            content.frames.push(subFrame);\n            offsetSubFrames += subFrame.header.size + 10;\n        }\n\n        return content;\n    };\n\n    // ### Read an ID3v2 Tag Frame\n    //\n    // Read [ID3v2 Tag frame](http://id3.org/id3v2.3.0#Declared_ID3v2_frames) located at `offset`\n    //  of DataView `view`. Returns null in the event that no tag-frame is found at `offset`\n    mp3Id3v2Parser.readId3v2TagFrame = function (view, offset) {\n        // All frames consist of a frame header followed by one or more fields containing the actual\n        // information. The frame header is 10 octets long and laid out as `IIIISSSSFF`, where\n        //\n        // * `IIII......`: Frame id (four characters)\n        // * `....SSSS..`: Size (frame size excluding frame header = frame size - 10)\n        // * `........FF`: Flags\n        var frame = {\n            header: {\n                id: lib.readStr.iso(view, offset, 4),\n                size: view.getUint32(offset + 4),\n                flagsOctet1: view.getUint8(offset + 8),\n                flagsOctet2: view.getUint8(offset + 9)\n            }\n        };\n\n        // An ID3v2 tag frame must have a length of at least 1 octet, excluding the header\n        if (frame.header.size < 1) { return frame; }\n\n        // A function to read the frame's content\n        var readContent = (function (read, id) { // jscs:disable requirePaddingNewLinesBeforeLineComments\n            // User-defined text-information frames\n            if (id === \"TXXX\") { return read.TXXX; }\n            // Text-information frames\n            if (id.charAt(0) === \"T\") { return read.T; }\n            // User-defined URL-link frames\n            if (id === \"WXXX\") { return read.WXXX; }\n            // URL-link frames\n            if (id.charAt(0) === \"W\") { return read.W; }\n            // Comment frames or Unsychronised lyrics/text transcription frames\n            if (id === \"COMM\" || id === \"USLT\") { return read.COMM; }\n            // For any other frame such as UFID, IPLS, USER, etc, return the reader function\n            //  that's named after the frame. Return a 'no-op reader' (which just returns\n            //  `undefined` as the frame's content) if no implementation found for given frame\n            return read[id] || lib.noOp;\n        }(readFrameContent, frame.header.id)); // jscs-enable requirePaddingNewLinesBeforeLineComments\n\n        // Store frame's friendly name\n        frame.name = id3v2TagFrameNames[frame.header.id];\n\n        // Read frame's content\n        frame.content = readContent(view, offset + 10, frame.header.size);\n\n        return frame;\n    };\n\n    // ### Read the ID3v2 Tag\n    //\n    // Read [ID3v2 Tag](http://id3.org/id3v2.3.0) located at `offset` of DataView `view`. Returns\n    //  null in the event that no tag is found at `offset`\n    mp3Id3v2Parser.readId3v2Tag = function (view, offset) {\n        offset || (offset = 0);\n\n        // The ID3v2 tag header, which should be the first information in the file, is 10 octets\n        //  long and laid out as `IIIVVFSSSS`, where\n        //\n        // * `III.......`: id, always \"ID3\" (0x49/73, 0x44/68, 0x33/51)\n        // * `...VV.....`: version (major version + revision number)\n        // * `.....F....`: flags: abc00000. a:unsynchronisation, b:extended header, c:experimental\n        // * `......SSSS`: tag's size as a synchsafe integer\n\n        // There should be at least 10 bytes ahead\n        if (view.byteLength - offset < 10) { return null; }\n\n        // The 'ID3' identifier is expected at given offset\n        if (!lib.isSeq(lib.seq.id3, view, offset)) { return null; }\n\n        //\n        var flagsOctet = view.getUint8(offset + 5);\n\n        //\n        var tag = {\n            _section: { type: \"ID3v2\", offset: offset },\n            header: {\n                majorVersion: view.getUint8(offset + 3),\n                minorRevision: view.getUint8(offset + 4),\n                flagsOctet: flagsOctet,\n                unsynchronisationFlag: (flagsOctet & 128) === 128,\n                extendedHeaderFlag: (flagsOctet & 64) === 64,\n                experimentalIndicatorFlag: (flagsOctet & 32) === 32,\n                size: lib.unsynchsafe(view.getUint32(offset + 6))\n            },\n            frames: []\n        };\n\n        // The size as expressed in the header is the size of the complete tag after\n        //  unsychronisation, including padding, excluding the header but not excluding the\n        //  extended header (total tag size - 10)\n        tag._section.byteLength = tag.header.size + 10;\n\n        // Index of octet following tag's last octet: The tag spans [offset, tagEnd)\n        //  (including the first 10 header octets)\n        var tagEnd = offset + tag._section.byteLength;\n\n        // TODO: Process extended header if present. The presence of an extended header will affect\n        //  the offset. Currently, it is asummed that no extended header is present so the offset\n        //  is fixed at 10 octets\n        // if (tag.header.extendedHeaderFlag) { /* TODO */ }\n\n        // Go on to read individual frames but only if the tag version is v2.3. This is the only\n        //  version currently supported\n        if (tag.header.majorVersion !== 3) { return tag; }\n\n        // To store frames as they're discovered while paring the tag\n        var frame;\n\n        // Move offset past the end of the tag header to start reading tag frames\n        offset += 10;\n        while (offset < tagEnd) {\n            // Locating a frame with a zeroed out id indicates that all valid frames have already\n            //  been parsed. It's all dead space hereon so practically we're done\n            if (view.getUint32(offset) === 0) { break; }\n\n            frame = mp3Id3v2Parser.readId3v2TagFrame(view, offset);\n\n            // Couldn't parse this frame so bail out\n            if (!frame) { break; }\n\n            tag.frames.push(frame);\n            offset += frame.header.size + 10;\n        }\n\n        return tag;\n    };\n}));\n","//     mp3-parser/xing v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false, require:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\", \"./lib\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") {\n        return createModule(exports, require(\"./lib\"));\n    }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3XingParser = globalObject.mp3XingParser;\n    createModule(globalObject.mp3XingParser = {\n        noConflict: function () {\n            var mp3XingParser = globalObject.mp3XingParser;\n            globalObject.mp3XingParser = previousMp3XingParser;\n            return (this.noConflict = function () { return mp3XingParser; }).call();\n        }\n    }, globalObject.mp3ParserLib);\n}(this, function (xingParser, lib) {\n    \"use strict\";\n\n    // ### Read the Xing Tag\n    //\n    // Read [Xing / Lame Tag](http://gabriel.mp3-tech.org/mp3infotag.html) located at `offset` of\n    //  DataView `view`. Returns null in the event that no frame is found at `offset`\n    xingParser.readXingTag = function (view, offset) {\n        offset || (offset = 0);\n\n        var tag = {\n            _section: { type: \"Xing\", offset: offset },\n            header: lib.readFrameHeader(view, offset)\n        };\n\n        var head = tag.header; // Convenience shortcut\n\n        // The Xing tag should begin with a valid frame header\n        if (!head) { return null; }\n\n        var xingOffset = offset +\n            lib.getXingOffset(head.mpegAudioVersionBits, head.channelModeBits);\n\n        // There should be at least 'offset' (header) + 4 (\"Xing\"/\"Info\") octets ahead\n        if (view.byteLength < xingOffset + 4) { return null; }\n\n        // A \"Xing\" or \"Info\" identifier should be present\n        tag.identifier = (lib.isSeq(lib.seq.xing, view, xingOffset) && \"Xing\") ||\n            (lib.isSeq(lib.seq.info, view, xingOffset) && \"Info\");\n        if (!tag.identifier) { return null; }\n\n        //\n        tag._section.byteLength = lib.getFrameByteLength(head.bitrate, head.samplingRate,\n            head.framePadding, head.mpegAudioVersionBits, head.layerDescriptionBits);\n        tag._section.nextFrameIndex = offset + tag._section.byteLength;\n\n        return tag;\n    };\n}));\n","//     mp3-parser v0.3.0\n\n//     https://github.com/biril/mp3-parser\n//     Licensed and freely distributed under the MIT License\n//     Copyright (c) 2013-2016 Alex Lambiris\n\n// ----\n\n/* jshint browser:true */\n/* global exports:false, define:false, require:false */\n(function (globalObject, createModule) {\n    \"use strict\";\n\n    // Export as a module or global depending on environment:\n\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\n    if (typeof define === \"function\" && define.amd) {\n        return define([\"exports\", \"./lib/lib\", \"./lib/id3v2\", \"./lib/xing\"], createModule);\n    }\n\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\n    if (typeof exports === \"object\") {\n        return createModule(exports, require(\"./lib/lib\"), require(\"./lib/id3v2\"),\n            require(\"./lib/xing\"));\n    }\n\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\n    var previousMp3Parser = globalObject.mp3Parser;\n    createModule(globalObject.mp3Parser = {\n        noConflict: function () {\n            var mp3Parser = globalObject.mp3Parser;\n            globalObject.mp3Parser = previousMp3Parser;\n            return (this.noConflict = function () { return mp3Parser; }).call();\n        }\n    }, globalObject.mp3ParserLib, globalObject.mp3Id3v2Parser, globalObject.mp3XingParser);\n}(this, function (mp3Parser, lib, id3v2Parser, xingParser) {\n    \"use strict\";\n\n    // ### TL;DR\n    //\n    // The parser exposes a collection of `read____` methods, each dedicated to reading a specific\n    //  section of the mp3 file. The current implementation includes `readFrameHeader`, `readFrame`,\n    //  `readId3v2Tag` and `readXingTag`. Each of these accepts a DataView-wrapped ArrayBuffer,\n    //  which should contain the actual mp3 data, and optionally an offset into the buffer.\n    //\n    // All methods return a description of the section read in the form of a hash containing\n    //  key-value pairs relevant to the section. For example the hash returned from\n    //  `readFrameHeader` always contains an `mpegAudioVersion` key of value \"MPEG Version 1\n    //  (ISO/IEC 11172-3)\" and a `layerDescription` key of value \"Layer III\". A description will\n    //  always have a `_section` hash with `type`, `byteLength` and `offset` keys:\n    //\n    //  * `type`: \"frame\", \"frameHeader\", \"Xing\" or \"ID3\"\n    //  * `byteLenfth`: Size of the section in bytes\n    //  * `offset`: Buffer offset at which this section resides\n\n    // ----\n\n    // ### Read a Frame Header\n    //\n    // Read and return description of header of frame located at `offset` of DataView `view`.\n    //  Returns `null` in the event that no frame header is found at `offset`\n    mp3Parser.readFrameHeader = function (view, offset) {\n        return lib.readFrameHeader(view, offset);\n    };\n\n    // ### Read a Frame\n    //\n    // Read and return description of frame located at `offset` of DataView `view`. Includes the\n    //  frame header description (see `readFrameHeader`) plus some basic information about the\n    //  frame - notably the frame's length in bytes. If `requireNextFrame` is set, the presence of\n    //  a _next_ valid frame will be required for _this_ frame to be regarded as valid. Returns\n    //  null in the event that no frame is found at `offset`\n    mp3Parser.readFrame = function (view, offset, requireNextFrame) {\n        return lib.readFrame(view, offset, requireNextFrame);\n    };\n\n    // ### Read the Last Frame\n    //\n    // Locate and return description of the very last valid frame in given DataView `view`. The\n    //  search is carried out in reverse, from given `offset` (or the very last octet if `offset`\n    //  is ommitted) to the first octet in the view. If `requireNextFrame` is set, the presence\n    //  of a next valid frame will be required for any found frame to be regarded as valid (causing\n    //  the method to essentially return the next-to-last frame on success). Returns `null` in the\n    //  event that no frame is found at `offset`\n    mp3Parser.readLastFrame = function (view, offset, requireNextFrame) {\n        offset || (offset = view.byteLength - 1);\n\n        var lastFrame = null;\n\n        for (; offset >= 0; --offset) {\n            if (view.getUint8(offset) === 255) {\n                // Located a candidate frame as 255 is a possible frame-sync byte\n                lastFrame = mp3Parser.readFrame(view, offset, requireNextFrame);\n                if (lastFrame) { return lastFrame; }\n            }\n        }\n\n        return null;\n    };\n\n    // ### Read the ID3v2 Tag\n    //\n    // Read and return description of [ID3v2 Tag](http://id3.org/id3v2.3.0) located at `offset` of\n    //  DataView `view`. (This will include any and all\n    //  [currently supported ID3v2 frames](https://github.com/biril/mp3-parser/wiki) located within\n    //  the tag). Returns `null` in the event that no tag is found at `offset`\n    mp3Parser.readId3v2Tag = function (view, offset) {\n        return id3v2Parser.readId3v2Tag(view, offset);\n    };\n\n    // ### Read the Xing Tag\n    //\n    // Read and return description of\n    //  [Xing / Lame Tag](http://gabriel.mp3-tech.org/mp3infotag.html) located at `offset` of\n    //  DataView `view`. Returns `null` in the event that no frame is found at `offset`\n    mp3Parser.readXingTag = function (view, offset) {\n        return xingParser.readXingTag(view, offset);\n    };\n\n    // ### Read all Tags up to First Frame\n    // Read and return descriptions of all tags found up to (and including) the very first frame.\n    //  Returns an array of sections which may include a description of a located ID3V2 tag, a\n    //  description of located Xing / Lame tag and a description of the a located first frame\n    //  ( See [this](http://www.rengels.de/computer/mp3tags.html) and\n    //  [this](http://stackoverflow.com/a/5013505) )\n    mp3Parser.readTags = function (view, offset) {\n        offset || (offset = 0);\n\n        var sections = [];\n        var section = null;\n        var isFirstFrameFound = false;\n        var bufferLength = view.byteLength;\n\n        var readers = [mp3Parser.readId3v2Tag, mp3Parser.readXingTag, mp3Parser.readFrame];\n        var numOfReaders = readers.length;\n\n        // While we haven't located the first frame, pick the next offset ..\n        for (; offset < bufferLength && !isFirstFrameFound; ++offset) {\n            // .. and try out each of the 'readers' on it\n            for (var i = 0; i < numOfReaders; ++i) {\n                section = readers[i](view, offset);\n\n                // If one of the readers successfully parses a section ..\n                if (section) {\n                    // .. store it ..\n                    sections.push(section);\n\n                    // .. and push the offset to the very end of end of that section. This way,\n                    //  we avoid iterating over offsets which definately aren't the begining of\n                    //  some section (they're part of the located section)\n                    offset += section._section.byteLength;\n\n                    // If the section we just parsed is a frame then we've actually located the\n                    //  first frame. Break out of the readers-loop making sure to set\n                    //  isFirstFrameFound (so that we also exit the outer loop)\n                    if (section._section.type === \"frame\") {\n                        isFirstFrameFound = true;\n                        break;\n                    }\n\n                    // The section is _not_ the first frame. So, having pushed the offset\n                    //  appropriately, retry all readers\n                    i = -1;\n                }\n            }\n        }\n\n        return sections;\n    };\n}));\n","import parser from 'mp3-parser';\n\nconst CHUNK_MAX_SIZE = 1000 * 1000;\nconst DEFAULT_CONCURRENCY = 4;\nconst CONCURRENCY =\n  ((typeof navigator !== 'undefined' && navigator.hardwareConcurrency) || 1) > 2\n    ? navigator.hardwareConcurrency\n    : DEFAULT_CONCURRENCY;\n\n/**\n * Creates a new ArrayBuffer out of two Uint8Arrays\n *\n * @private\n * @param   {Uint8Array}  baseUint8Array  first Uint8Array.\n * @param   {Uint8Array}  buffer          second Uint8Array.\n * @return  {ArrayBuffer}                  The new ArrayBuffer\n */\nfunction makeChunk(array1, array2) {\n  const tmp = new Uint8Array(array1.byteLength + array2.byteLength);\n  tmp.set(array1, 0);\n  tmp.set(array2, array1.byteLength);\n  return tmp.buffer;\n}\n\nfunction makeSaveChunk(chunkArrayBuffers, tagsUInt8Array, sourceUInt8Array) {\n  return function saveChunk(chunk) {\n    chunkArrayBuffers.push(\n      makeChunk(\n        tagsUInt8Array,\n        sourceUInt8Array.subarray(\n          chunk.frames[0]._section.offset,\n          chunk.frames[chunk.frames.length - 1]._section.offset +\n            chunk.frames[chunk.frames.length - 1]._section.byteLength\n        )\n      )\n    );\n  };\n}\n\nfunction emptyChunk(chunk) {\n  chunk.byteLength = 0;\n  chunk.frames.length = 0;\n}\n\nfunction addChunkFrame(chunk, frame) {\n  chunk.byteLength = chunk.byteLength + frame._section.byteLength;\n  chunk.frames.push(frame);\n}\n\nconst asyncWorker = (source, items, fn, output) => async () => {\n  let next;\n  while ((next = items.pop())) {\n    output[source.get(next)] = await fn(next);\n  }\n};\n\nfunction getArrayBuffer(file) {\n  return new Promise((resolve) => {\n    let fileReader = new FileReader();\n    fileReader.onloadend = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.readAsArrayBuffer(file);\n  });\n}\n\n// Use a promise wrapper on top of event based syntax\n// for browsers (Safari) which do not support promise-based syntax.\n// function decodeArrayBuffer(audioCtx, arrayBuffer) {\n//   return new Promise(audioCtx.decodeAudioData.bind(audioCtx, arrayBuffer));\n// }\nfunction decodeArrayBuffer(audioCtx, arrayBuffer) {\n  return new Promise((resolve, reject) => {\n    audioCtx.decodeAudioData(\n      arrayBuffer,\n      (buffer) => console.debug(buffer) || resolve(buffer),\n      (err) => console.debug(err) || reject(err)\n    );\n  });\n  // return new Promise(audioCtx.decodeAudioData.bind(audioCtx, arrayBuffer));\n}\n\nasync function getFileAudioBuffer(file, audioCtx, options = {}) {\n  /* Copyright (c) 2019, TimothÃ©e 'Tim' Pillard, @ziir @tpillard - ISC */\n\n  const { concurrency = CONCURRENCY } = options;\n\n  const arrayBuffer = await getArrayBuffer(file);\n  const view = new DataView(arrayBuffer);\n\n  const tags = parser.readTags(view);\n  const firstFrame = tags.pop();\n  console.log(tags);\n  const uInt8Array = new Uint8Array(arrayBuffer);\n  const tagsUInt8Array = uInt8Array.subarray(0, firstFrame._section.offset);\n  const chunkArrayBuffers = [];\n  const saveChunk = makeSaveChunk(\n    chunkArrayBuffers,\n    tagsUInt8Array,\n    uInt8Array\n  );\n  let chunk = { byteLength: 0, frames: [] };\n  let next = firstFrame._section.offset + firstFrame._section.byteLength;\n  while (next) {\n    const frame = parser.readFrame(view, next);\n    next = frame && frame._section.nextFrameIndex;\n\n    if (frame) {\n      const chunkEnd =\n        chunk && chunk.byteLength + frame._section.byteLength >= CHUNK_MAX_SIZE;\n      if (chunkEnd) {\n        saveChunk(chunk);\n        emptyChunk(chunk);\n      }\n\n      addChunkFrame(chunk, frame);\n    }\n\n    if (chunk && (!frame || !next)) {\n      saveChunk(chunk);\n    }\n  }\n\n  const workers = [];\n  const source = new Map(chunkArrayBuffers.map((chunk, idx) => [chunk, idx]));\n  const audioBuffers = new Array(chunkArrayBuffers.length);\n  const decode = decodeArrayBuffer.bind(null, audioCtx);\n\n  for (let i = 0; i < Math.min(concurrency, source.size); i++) {\n    workers.push(\n      asyncWorker(source, chunkArrayBuffers, decode, audioBuffers)()\n    );\n  }\n  await Promise.all(workers);\n\n  const { numberOfChannels, sampleRate } = audioBuffers[0];\n  let length = audioBuffers.reduce((acc, current) => acc + current.length, 0);\n\n  const audioBuffer = audioCtx.createBuffer(\n    numberOfChannels,\n    length,\n    sampleRate\n  );\n\n  for (let j = 0; j < numberOfChannels; j++) {\n    const channelData = audioBuffer.getChannelData(j);\n    let offset = 0;\n    for (let i = 0; i < audioBuffers.length; i++) {\n      channelData.set(audioBuffers[i].getChannelData(j), offset);\n      offset += audioBuffers[i].length;\n    }\n  }\n\n  return audioBuffer;\n}\n\nexport { getFileAudioBuffer };\n//# sourceMappingURL=decode-audio-data-fast.esm.js.map\n","export function getFileArrayBuffer(file) {\n  return new Promise((resolve) => {\n    let fileReader = new FileReader();\n    fileReader.onloadend = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.readAsArrayBuffer(file);\n  });\n}\n","import { getFileAudioBuffer as getMP3FileAudioBuffer } from '@soundcut/decode-audio-data-fast';\n\nimport { getFileArrayBuffer } from './getFileArrayBuffer';\n\n// Use a promise wrapper on top of event based syntax\n// for browsers (Safari) which do not support promise-based syntax.\nfunction decodeAudioData(audioCtx, arrayBuffer) {\n  return new Promise(audioCtx.decodeAudioData.bind(audioCtx, arrayBuffer));\n}\n\nexport function getFileAudioBuffer(file, audioCtx, opts) {\n  const safari = !!window.webkitAudioContext;\n  const options = opts || {};\n\n  const slow = options.slow || safari;\n\n  if (slow) {\n    return getFileArrayBuffer(file).then((arrayBuffer) => {\n      return decodeAudioData(audioCtx, arrayBuffer);\n    });\n  }\n\n  return getMP3FileAudioBuffer(file, audioCtx).catch((err) => {\n    // Unable to decode audio data fast.\n    // Either because:\n    // - the file is not MP3\n    // - the browser does not support.. something?\n    // Fallback to regular AudioBuffer.decodeAudioData()\n    console.error(err);\n    return getFileArrayBuffer(file, audioCtx, { slow: true });\n  });\n}\n","export function withMediaSession(fn) {\n  if ('mediaSession' in navigator) {\n    fn();\n  }\n}\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","export function hexToRGB(hex) {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return [\n    parseInt(result[1], 16),\n    parseInt(result[2], 16),\n    parseInt(result[3], 16),\n  ];\n}\n","import { html, render } from 'uhtml';\n\nimport { checkPassiveEventListener } from './helpers/checkPassiveEventListener';\nimport { applyFocusVisiblePolyfill } from './helpers/focus-visible';\nimport { getFileAudioBuffer } from './helpers/getFileAudioBuffer';\nimport { withMediaSession } from './helpers/withMediaSession';\nimport { getDisplayName } from './helpers/getDisplayName';\nimport { fetchSource } from './helpers/fetchSource';\nimport { formatTime } from './helpers/formatTime';\nimport { hexToRGB } from './helpers/hexToRGB';\nimport { Play } from './components/Icons/Play';\nimport { Pause } from './components/Icons/Pause';\n\nconst SPACING = 20;\nconst CONTAINER_WIDTH = 900;\nconst CONTAINER_HEIGHT = 260;\nconst HEIGHT = CONTAINER_HEIGHT - SPACING * 2;\nconst BAR_WIDTH = 4;\nconst BAR_HANDLE_RADIUS = 8;\nconst BAR_CENTER = (BAR_WIDTH - 1) / 2;\nconst BAR_GAP = false;\nconst FONT_FAMILY = 'monospace';\nconst FONT_SIZE = 10;\nconst FONT = `${FONT_SIZE}px ${FONT_FAMILY}`;\nconst TIME_ANNOTATION_WIDTH = 40;\nconst BAR_COLOR = '#166a77';\nconst BACKGROUND_COLOR = '#113042';\nconst SLICE_COLOR = '#37f0c2';\n\nclass AudioWaveformPlayer extends HTMLElement {\n  constructor() {\n    super().attachShadow({ mode: 'open' });\n    this.renderer = render.bind(this, this.shadowRoot);\n    this.audioRef = this.audioRef.bind(this);\n    this.handlePlayPauseClick = this.handlePlayPauseClick.bind(this);\n    this.handleSourceTimeUpdate = this.handleSourceTimeUpdate.bind(this);\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n\n    this.pixelRatio =\n      // FIXME: Force pixelRatio=1 otherwise devices > 1 only draw half\n      1 || window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI;\n    this.halfPixel = 0.5 / this.pixelRatio;\n  }\n\n  get src() {\n    return this.getAttribute('src');\n  }\n\n  async connectedCallback() {\n    this.supportsPassiveEventListener = checkPassiveEventListener();\n    this.evtHandlerOptions = this.supportsPassiveEventListener\n      ? { passive: true }\n      : true;\n    applyFocusVisiblePolyfill(this.shadowRoot);\n\n    this.render();\n    this.setupContainer();\n\n    this.file = await fetchSource(this.src);\n    this.objectURL = URL.createObjectURL(this.file);\n\n    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    getFileAudioBuffer(this.file, this.audioCtx).then((audioBuffer) => {\n      this.audioBuffer = audioBuffer;\n      this.onAudioDecoded();\n    });\n  }\n\n  audioRef(audio) {\n    if (audio && audio !== this.audio) {\n      if (this.audio) {\n        this.audio.removeEventListener(\n          'timeupdate',\n          this.handleSourceTimeUpdate,\n          this.evtHandlerOptions\n        );\n      }\n      this.audio = audio;\n      this.audio.addEventListener(\n        'timeupdate',\n        this.handleSourceTimeUpdate,\n        this.evtHandlerOptions\n      );\n    }\n  }\n\n  /**\n   * Set the rendered length (different from the length of the audio).\n   *\n   * @param {number} length\n   */\n  setLength(length) {\n    this.splitPeaks = [];\n    this.mergedPeaks = [];\n    // Set the last element of the sparse array so the peak arrays are\n    // appropriately sized for other calculations.\n    const channels = this.audioBuffer.numberOfChannels;\n    let c;\n    for (c = 0; c < channels; c++) {\n      this.splitPeaks[c] = [];\n      this.splitPeaks[c][2 * (length - 1)] = 0;\n      this.splitPeaks[c][2 * (length - 1) + 1] = 0;\n    }\n    this.mergedPeaks[2 * (length - 1)] = 0;\n    this.mergedPeaks[2 * (length - 1) + 1] = 0;\n  }\n\n  /**\n   * Compute the max and min value of the waveform when broken into <length> subranges.\n   *\n   * @param {number} length How many subranges to break the waveform into.\n   * @param {number} first First sample in the required range.\n   * @param {number} last Last sample in the required range.\n   * @return {number[]|number[][]} Array of 2*<length> peaks or array of arrays of\n   * peaks consisting of (max, min) values for each subrange.\n   */\n  getPeaks(length, first, last) {\n    first = first || 0;\n    last = last || length - 1;\n\n    this.setLength(length);\n\n    const sampleSize = this.audioBuffer.length / length;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n    const channels = this.audioBuffer.numberOfChannels;\n    let c;\n\n    for (c = 0; c < channels; c++) {\n      const peaks = this.splitPeaks[c];\n      const chan = this.audioBuffer.getChannelData(c);\n      let i;\n\n      for (i = first; i <= last; i++) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        let min = 0;\n        let max = 0;\n        let j;\n\n        for (j = start; j < end; j += sampleStep) {\n          const value = chan[j];\n\n          if (value > max) {\n            max = value;\n          }\n\n          if (value < min) {\n            min = value;\n          }\n        }\n\n        peaks[2 * i] = max;\n        peaks[2 * i + 1] = min;\n\n        if (c == 0 || max > this.mergedPeaks[2 * i]) {\n          this.mergedPeaks[2 * i] = max;\n        }\n\n        if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {\n          this.mergedPeaks[2 * i + 1] = min;\n        }\n      }\n    }\n\n    return this.mergedPeaks;\n  }\n\n  async onAudioDecoded() {\n    this.render();\n    this.setupCanvases();\n\n    this.canvases.addEventListener(\n      'mousemove',\n      this.handleMouseMove,\n      this.evtHandlerOptions\n    );\n    this.canvases.addEventListener(\n      'touchmove',\n      this.handleMouseMove,\n      this.evtHandlerOptions\n    );\n\n    this.canvases.addEventListener(\n      'mousedown',\n      this.handleMouseDown,\n      this.evtHandlerOptions\n    );\n    this.canvases.addEventListener(\n      'touchstart',\n      this.handleMouseDown,\n      this.evtHandlerOptions\n    );\n    this.canvases.addEventListener(\n      'keydown',\n      this.handleKeyDown,\n      this.evtHandlerOptions\n    );\n\n    const width = this.width;\n    const start = 0;\n    const end = this.width;\n\n    const peaks = this.getPeaks(width, start, end);\n    await this.drawBars(peaks, 0, this.width);\n    this.drawn = true;\n  }\n\n  getDuration() {\n    return this.audioBuffer.duration;\n  }\n\n  handleKeyDown(evt) {\n    const duration = this.getDuration();\n    const currentTime = this.audio.currentTime;\n\n    let percentage = Math.round((currentTime / duration) * 100);\n    let stop = false;\n\n    switch (evt.key) {\n      case 'ArrowLeft':\n        percentage -= 1;\n        break;\n      case 'ArrowRight':\n        percentage += 1;\n        break;\n      case 'ArrowUp':\n        percentage += 10;\n        break;\n      case 'ArrowDown':\n        percentage -= 10;\n        break;\n      case 'Home':\n        percentage = 0;\n        break;\n      case 'End':\n        percentage = 99.9; // 100 would trigger onEnd, so only 99.9\n        break;\n      default:\n        stop = true;\n        break;\n    }\n\n    if (stop) return;\n\n    percentage = Math.min(Math.max(percentage, 0), 100);\n\n    this.audio.currentTime = (duration / 100) * percentage;\n  }\n\n  handleMouseMove(evt) {\n    const touch = evt.touches;\n    requestAnimationFrame(() => {\n      const duration = this.getDuration();\n      const xContainer =\n        (touch ? evt.touches[0] : evt).clientX -\n        this.boundingClientRect.left +\n        this.container.scrollLeft;\n\n      const newBoundaryPos = Math.min(\n        Math.max(xContainer, SPACING),\n        this.width + SPACING\n      );\n\n      const canvasCtx = this.canvasContexts['cursor'];\n      canvasCtx.clearRect(0, 0, this.containerWidth, CONTAINER_HEIGHT);\n      this.drawBoundary(canvasCtx, newBoundaryPos);\n    });\n  }\n\n  handleMouseDown(evt) {\n    const touch = evt.touches;\n    const xContainer =\n      (touch ? evt.touches[0] : evt).clientX -\n      this.boundingClientRect.left +\n      this.container.scrollLeft;\n\n    const duration = this.getDuration();\n    const boundary = Math.min(Math.max(xContainer - SPACING, 0), this.width);\n    const currentTime = (duration / this.width) * boundary;\n\n    this.audio.currentTime = currentTime;\n\n    this.canvases.addEventListener(\n      'mouseup',\n      this.handleMouseUp,\n      this.evtHandlerOptions\n    );\n    this.canvases.addEventListener(\n      'touchend',\n      this.handleMouseUp,\n      this.evtHandlerOptions\n    );\n  }\n\n  async handleMouseUp(evt) {\n    this.canvases.removeEventListener(\n      'touchend',\n      this.handleMouseUp,\n      this.evtHandlerOptions\n    );\n    this.canvases.removeEventListener(\n      'mouseup',\n      this.handleMouseUp,\n      this.evtHandlerOptions\n    );\n\n    const xContainer =\n      (evt.changedTouches ? evt.changedTouches[0] : evt).clientX -\n      this.boundingClientRect.left +\n      this.container.scrollLeft;\n\n    const duration = this.getDuration();\n    const boundary = Math.min(Math.max(xContainer - SPACING, 0), this.width);\n    const currentTime = (duration / this.width) * boundary;\n\n    this.audio.currentTime = currentTime;\n  }\n\n  drawBoundary(canvasCtx, x) {\n    canvasCtx.fillStyle = SLICE_COLOR;\n    canvasCtx.fillRect(x, 0, BAR_WIDTH / 2, HEIGHT);\n    canvasCtx.beginPath();\n    canvasCtx.arc(\n      x + BAR_CENTER,\n      HEIGHT - BAR_HANDLE_RADIUS,\n      BAR_HANDLE_RADIUS,\n      0,\n      2 * Math.PI\n    );\n    canvasCtx.fill();\n    canvasCtx.beginPath();\n    canvasCtx.arc(\n      x + BAR_CENTER,\n      BAR_HANDLE_RADIUS,\n      BAR_HANDLE_RADIUS,\n      0,\n      2 * Math.PI\n    );\n    canvasCtx.fill();\n\n    const time = Math.max((this.getDuration() / this.width) * (x - SPACING), 0);\n    const formattedTime = formatTime(time);\n    const textSpacing = BAR_HANDLE_RADIUS + SPACING / 2;\n    const textX =\n      this.width - x < TIME_ANNOTATION_WIDTH + textSpacing\n        ? x - TIME_ANNOTATION_WIDTH - textSpacing\n        : x + textSpacing;\n    const textY = FONT_SIZE;\n    canvasCtx.fillText(formattedTime, textX, textY);\n  }\n\n  handleSourceTimeUpdate() {\n    if (!this.drawn) return;\n\n    requestAnimationFrame(() => {\n      const duration = this.getDuration();\n\n      const x = Math.round((this.width / duration) * this.audio.currentTime);\n      const startX = Math.round((this.width / duration) * 0);\n      const width = x - startX;\n\n      const canvasCtx = this.canvasContexts['progress'];\n\n      if (!width) {\n        canvasCtx.clearRect(0, 0, this.width, HEIGHT);\n        return;\n      }\n\n      const partial = this.canvasContexts['waveform'].getImageData(\n        startX,\n        0,\n        width,\n        HEIGHT\n      );\n      const imageData = partial.data;\n\n      const progressColor = hexToRGB(SLICE_COLOR);\n      // Loops through all of the pixels and modifies the components.\n      for (let i = 0, n = imageData.length; i < n; i += 4) {\n        imageData[i] = progressColor[0]; // Red component\n        imageData[i + 1] = progressColor[1]; // Green component\n        imageData[i + 2] = progressColor[2]; // Blue component\n        //pix[i+3] is the transparency.\n      }\n\n      canvasCtx.clearRect(0, 0, this.width, HEIGHT);\n      canvasCtx.putImageData(partial, startX, 0);\n      this.render();\n    });\n  }\n\n  drawBars(peaks, start, end) {\n    return new Promise((resolve) => {\n      this.prepareDraw(\n        peaks,\n        start,\n        end,\n        ({ hasMinVals, offsetY, halfH, peaks }) => {\n          // Skip every other value if there are negatives.\n          const peakIndexScale = hasMinVals ? 2 : 1;\n          const length = peaks.length / peakIndexScale;\n          const bar = BAR_WIDTH * this.pixelRatio;\n          const gap = BAR_GAP ? Math.max(this.pixelRatio, ~~(bar / 2)) : 0;\n          const step = bar + gap;\n\n          const scale = length / this.width;\n          const first = start;\n          const last = end;\n          let i;\n\n          this.canvasContexts['waveform'].fillStyle = BAR_COLOR;\n          for (i = first; i < last; i += step) {\n            const peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;\n            const h = Math.round((peak / 1) * halfH);\n            this.canvasContexts['waveform'].fillRect(\n              i + this.halfPixel,\n              halfH - h + offsetY,\n              bar + this.halfPixel,\n              h * 2\n            );\n          }\n          resolve();\n        }\n      );\n    });\n  }\n\n  prepareDraw(peaks, start, end, fn) {\n    return requestAnimationFrame(() => {\n      // Bar wave draws the bottom only as a reflection of the top,\n      // so we don't need negative values\n      const hasMinVals = peaks.some((val) => val < 0);\n      const height = HEIGHT - SPACING * 2 * this.pixelRatio;\n      const offsetY = SPACING;\n      const halfH = height / 2;\n\n      return fn({\n        hasMinVals: hasMinVals,\n        height: height,\n        offsetY: offsetY,\n        halfH: halfH,\n        peaks: peaks,\n      });\n    });\n  }\n\n  doSnapshot(canvas) {\n    this.snapshots[canvas].push(\n      this.canvasContexts[canvas].getImageData(0, 0, this.width, HEIGHT)\n    );\n  }\n\n  setupContainer() {\n    this.container = this.shadowRoot.getElementById('root');\n    this.boundingClientRect = this.container.getBoundingClientRect();\n    this.containerWidth = this.boundingClientRect.width;\n    this.width = this.boundingClientRect.width - SPACING * 2;\n  }\n\n  setupCanvases() {\n    this.canvasContexts = {};\n    this.snapshots = {};\n    this.canvases = this.container.querySelector('#canvases');\n    Array.from(this.canvases.children).forEach((node) => {\n      const canvas = node.id.replace('-canvas', '');\n      this.canvases[canvas] = node;\n      this.canvasContexts[canvas] = node.getContext('2d');\n      this.canvasContexts[canvas].clearRect(0, 0, this.width, HEIGHT);\n      this.canvasContexts[canvas].font = FONT;\n      this.snapshots[canvas] = [];\n    });\n  }\n\n  async play() {\n    withMediaSession(() => {\n      navigator.mediaSession.playbackState = 'playing';\n    });\n    try {\n      await this.audio.play();\n    } catch (err) {\n      console.error(err);\n      // Browser refuses to play audio from an ObjectURL...\n      // Probably because of missing MIME type in `<source type=\"...\"`>\n      // Fallback to streaming remote audio.\n      // /!\\ Disabled for now, as using a <audio> element in render() w/ ref.\n      // if (this.audio.src !== this.src && err.name.match(/NotSupportedError/)) {\n      //   this.audio.removeEventListener(\n      //     'timeupdate',\n      //     this.handleSourceTimeUpdate,\n      //     this.evtHandlerOptions\n      //   );\n      //   this.audio = new Audio(this.src);\n      //   return this.play();\n      // }\n    }\n    this.render();\n  }\n\n  pause() {\n    withMediaSession(() => {\n      navigator.mediaSession.playbackState = 'paused';\n    });\n    this.audio.pause();\n    this.render();\n  }\n\n  setMediaMetaData() {\n    const title = getDisplayName(this.file.name);\n    navigator.mediaSession.metadata = new MediaMetadata({\n      title,\n    });\n    this.mediaMetadata = navigator.mediaSession.metadata;\n  }\n\n  togglePlayPause() {\n    withMediaSession(() => {\n      if (!this.mediaMetadata) {\n        this.setMediaMetaData();\n      }\n      navigator.mediaSession.setActionHandler('play', this.play);\n      navigator.mediaSession.setActionHandler('pause', this.pause);\n    });\n\n    if (this.audio.paused) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  }\n\n  handlePlayPauseClick(evt) {\n    evt.preventDefault();\n    this.togglePlayPause();\n  }\n\n  render() {\n    const disabled = !this.audio || undefined;\n    const paused = !this.audio || this.audio.paused;\n    const progress =\n      disabled || !this.audioBuffer\n        ? 0\n        : Math.round((this.audio.currentTime / this.getDuration()) * 100);\n\n    return this.renderer(html`\n      <style>\n        ${`\n        * {\n          box-sizing: border-box;\n        }\n\n        #root {\n          width: 100%;\n          max-width: ${CONTAINER_WIDTH}px;\n          margin: 0 auto;\n          margin-top: 150px;\n          background-color: ${BACKGROUND_COLOR};\n          border: 0;\n          border-radius: ${SPACING}px;\n          padding: ${SPACING}px 0;\n          overflow-x: auto;\n        }\n\n        #canvases {\n          position: relative;\n          height: 100%;\n        }\n\n        canvas {\n          position: absolute;\n          top: ${SPACING}px;\n          left: ${SPACING}px;\n          background-color: transparent;\n        }\n\n        #progress-canvas:focus {\n          outline: 0;\n          box-shadow: ${SLICE_COLOR} 0 0 2px 2px;\n        }\n  \n        #progress-canvas:focus:not(.focus-visible) {\n          box-shadow: none;\n        }\n\n        #cursor-canvas {\n          left: 0;\n        }\n\n        #controls {\n          display: flex;\n          justify-content: center;\n        }\n\n        button {\n          width: 48px;\n          height: 48px;\n          border-radius: 50%;\n          background: transparent;\n          border: 3px solid transparent;\n          border-color: ${SLICE_COLOR};\n        }\n\n        button,\n        button:hover,\n        button:active,\n        button:focus {\n          outline: 0;\n          box-shadow: none;\n        }\n\n        button:hover {\n          background-color: rgba(${hexToRGB(BAR_COLOR)}, 0.6);\n        }\n\n        button:active {\n          background-color: ${BAR_COLOR};\n        }\n\n        button:focus {\n          box-shadow: ${SLICE_COLOR} 0 0 2px 2px;\n        }\n\n        button:focus:not(.focus-visible) {\n          box-shadow: none;\n        }\n\n        #play-pause[data-state=\"play\"] svg {\n          margin-left: 3px;\n        }\n      `}\n      </style>\n      <div id=\"root\" aria-label=\"Audio Player\" role=\"region\">\n        ${this.audioBuffer &&\n        html`\n          <div id=\"canvases\" style=\"${`max-height:${CONTAINER_HEIGHT}px`}\">\n            <canvas\n              id=\"waveform-canvas\"\n              width=\"${this.width}\"\n              height=\"${HEIGHT}\"\n            />\n            <canvas\n              id=\"progress-canvas\"\n              width=\"${this.width}\"\n              height=\"${HEIGHT}\"\n              tabindex=\"0\"\n              aria-valuetext=\"seek audio keyboard slider\"\n              aria-valuemax=\"100\"\n              aria-valuemin=\"0\"\n              aria-valuenow=${progress}\n              role=\"slider\"\n            />\n            <canvas\n              id=\"cursor-canvas\"\n              width=\"${this.containerWidth}\"\n              height=\"${HEIGHT}\"\n            />\n          </div>\n        `}\n        <div id=\"controls\">\n          <button\n            id=\"play-pause\"\n            disabled=${disabled}\n            onclick=${this.handlePlayPauseClick}\n            data-state=${!paused ? 'pause' : 'play'}\n            aria-label=${!paused ? 'Pause' : 'Play'}\n          >\n            ${!paused ? Pause() : Play()}\n          </button>\n        </div>\n        <audio ref=${this.audioRef}>\n          ${this.objectURL && this.file\n            ? html` <source src=${this.objectURL} type=${this.file.type} /> `\n            : ''}\n        </audio>\n      </div>\n    `);\n  }\n}\n\nObject.defineProperty(AudioWaveformPlayer, 'observedAttributes', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: ['src'],\n});\n\nexport { AudioWaveformPlayer };\n","export async function fetchSource(url) {\n  const fetchPromise = fetch(url, {\n    method: 'GET',\n    headers: {\n      Accept: 'audio/*',\n    },\n  });\n\n  try {\n    const response = await fetchPromise;\n    if (response) {\n      if (response.status !== 200) {\n        const error = new Error('Unable to fetch source');\n        error.response = response;\n        throw error;\n      }\n    }\n\n    const blob = await response.blob();\n    let filename = 'Untitled';\n    try {\n      filename = response.headers\n        .get('content-disposition')\n        .match(/filename=\"(.+)\"/)[1];\n    } catch (err) {\n      // pass\n    }\n    return new File([blob], filename, {\n      type: (response.headers.get('content-type') || '').split(';')[0],\n    });\n  } catch (err) {\n    console.error({ err });\n    throw err;\n  }\n}\n","export function formatTime(time) {\n  return [\n    Math.floor((time % 3600) / 60), // minutes\n    ('00' + Math.floor(time % 60)).slice(-2), // seconds\n    ('00' + Math.floor((time % 1) * 100)).slice(-2), // tenth miliseconds\n  ].join(':');\n}\n","import { decode } from 'punycode';\n\nexport function getDisplayName(str) {\n  let ret = str;\n  try {\n    ret = decode(str);\n  } catch (err) {\n    // pass\n  }\n\n  return ret || 'Untitled';\n}\n","import { svg } from 'uhtml';\n\nexport function Play() {\n  return svg`\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"#37f0c2\"\n      stroke-width=\"2\"\n      stroke-linecap=\"square\"\n      stroke-linejoin=\"arcs\"\n    >\n      <polygon points=\"5 3 19 12 5 21 5 3\" />\n    </svg>\n  `;\n}\n","import { svg } from 'uhtml';\n\nexport function Pause(id = 'default') {\n  return svg`\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"#37f0c2\"\n      stroke-width=\"2\"\n      stroke-linecap=\"square\"\n      stroke-linejoin=\"arcs\"\n    >\n      <rect x=\"6\" y=\"4\" width=\"4\" height=\"16\" />\n      <rect x=\"14\" y=\"4\" width=\"4\" height=\"16\" />\n    </svg>\n  `;\n}\n","import { AudioWaveformPlayer } from './AudioWaveformPlayer.js';\n\ncustomElements.define('waveform-player', AudioWaveformPlayer);\n"],"names":["_","get","key","set","value","attr","empty","node","notNode","selfClosing","trimEnd","isNode","template","i","test","regular","original","name","extra","replace","isArray","Array","indexOf","slice","diffable","operation","nodeType","firstChild","lastChild","range","document","createRange","setStartAfter","setEndAfter","deleteContents","remove","valueOf","createContent","FRAGMENT","TEMPLATE","createHTML","create","html","innerHTML","content","childNodes","selector","RegExp","$1","querySelectorAll","append","markup","type","createSVG","root","length","appendChild","element","createDocumentFragment","createElementNS","svg","reducePath","createPath","path","parentNode","push","call","createTreeWalker","importNode","IE","createFragment","text","createWalker","fragment","diff","comment","oldNodes","newNodes","a","b","before","bLength","aEnd","bEnd","aStart","bStart","map","insertBefore","has","removeChild","nextSibling","Map","index","sequence","replaceChild","udomdiff","handleAttribute","current","ref","values","removeAttribute","setAttribute","aria","dataset","data","setter","oldValue","toLowerCase","newValue","info","removeEventListener","addEventListener","event","orphan","attributeNode","createAttributeNS","removeAttributeNode","setAttributeNodeNS","attribute","handlers","options","reduceRight","this","nodes","anyContent","textContent","createTextNode","String","handleAnything","prefix","cache","umap","WeakMap","mapTemplate","chunk","$2","output","join","trim","instrument","tw","search","nextNode","hasAttribute","getAttribute","tagName","mapUpdates","updates","unroll","unrollValues","entry","wire","createEntry","ELEMENT_NODE","[object Object]","persistent","stack","hole","Hole","splice","defineProperties","Object","tag","keyed","for","id","memo","fixed","render","where","what","checkPassiveEventListener","passiveSupported","undefined","passive","window","err","applyFocusVisiblePolyfill","scope","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesAllowlist","url","tel","email","password","number","date","month","week","time","datetime","datetime-local","isValidFocusTarget","el","nodeName","classList","addFocusVisibleClass","contains","add","onPointerDown","e","addInitialPointerMoveListeners","onInitialPointerMove","target","metaKey","altKey","ctrlKey","activeElement","visibilityState","readOnly","isContentEditable","clearTimeout","setTimeout","Node","DOCUMENT_FRAGMENT_NODE","host","DOCUMENT_NODE","documentElement","CustomEvent","error","createEvent","initCustomEvent","dispatchEvent","lib","octetToBinRep","octet","getFrameByteLength","kbitrate","samplingRate","padding","mpegVersion","layerVersion","sampleLength","sampleLengthMap","paddingSize","byteRate","Math","floor","getXingOffset","channelMode","mono","v1l1Bitrates","0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010","1011","1100","1101","1110","1111","v1l2Bitrates","v1l3Bitrates","v2l1Bitrates","v2l2Bitrates","v2l3Bitrates","v1SamplingRates","00","01","10","11","v2SamplingRates","v25SamplingRates","channelModes","mpegVersionDescription","layerDescription","bitrateMap","samplingRateMap","v1SampleLengths","v2SampleLengths","wordSeqFromStr","str","seq","charCodeAt","id3","xing","noOp","unsynchsafe","out","mask","isSeq","view","offset","getUint8","locateSeq","l","locateStrTrm","iso","ucs","trmOffset","readStr","fromCharCode","apply","Uint8Array","buffer","getUint16","Uint16Array","readTrmStr","readFrameHeader","byteLength","b2","substr","header","_section","mpegAudioVersionBits","mpegAudioVersion","layerDescriptionBits","isProtected","protectionBit","b3","bitrateBits","bitrate","samplingRateBits","frameIsPaddedBit","frameIsPadded","framePadding","privateBit","b4","channelModeBits","readFrame","requireNextFrame","frame","head","nextFrameIndex","xingOffset","createModule","exports","mp3Id3v2Parser","id3v2TagFrameNames","AENC","APIC","CHAP","COMM","COMR","ENCR","EQUA","ETCO","GEOB","GRID","IPLS","LINK","MCDI","MLLT","OWNE","PRIV","PCNT","POPM","POSS","RBUF","RVAD","RVRB","SYLT","SYTC","TALB","TBPM","TCOM","TCON","TCOP","TDAT","TDLY","TENC","TEXT","TFLT","TIME","TIT1","TIT2","TIT3","TKEY","TLAN","TLEN","TMED","TOAL","TOFN","TOLY","TOPE","TORY","TOWN","TPE1","TPE2","TPE3","TPE4","TPOS","TPUB","TRCK","TRDA","TRSN","TRSO","TSIZ","TSRC","TSSE","TYER","TXXX","UFID","USER","USLT","WCOM","WCOP","WOAF","WOAR","WOAS","WORS","WPAY","WPUB","WXXX","readFrameContent","T","encoding","enc","offsetBeg","offsetTrm","description","W","language","ownerIdentifier","identifier","DataView","offsetNextStrTrm","privateData","counter","getUint32","rating","mimeType","pictureType","pictureData","startTime","endTime","startOffset","endOffset","offsetSubFrames","frames","subFrame","readId3v2TagFrame","size","flagsOctet1","flagsOctet2","read","readContent","charAt","readId3v2Tag","flagsOctet","majorVersion","minorRevision","unsynchronisationFlag","extendedHeaderFlag","experimentalIndicatorFlag","tagEnd","require$$0","xingParser","readXingTag","mp3Parser","id3v2Parser","readLastFrame","lastFrame","readTags","sections","section","isFirstFrameFound","bufferLength","readers","numOfReaders","require$$1","require$$2","CONCURRENCY","navigator","hardwareConcurrency","makeSaveChunk","chunkArrayBuffers","tagsUInt8Array","sourceUInt8Array","array1","array2","tmp","makeChunk","subarray","emptyChunk","addChunkFrame","asyncWorker","source","items","fn","async","next","pop","decodeArrayBuffer","audioCtx","arrayBuffer","Promise","resolve","reject","decodeAudioData","console","debug","getFileAudioBuffer","file","concurrency","fileReader","FileReader","onloadend","result","readAsArrayBuffer","getArrayBuffer","tags","parser","firstFrame","log","uInt8Array","saveChunk","workers","idx","audioBuffers","decode","bind","min","all","numberOfChannels","sampleRate","reduce","acc","audioBuffer","createBuffer","j","channelData","getChannelData","getFileArrayBuffer","opts","safari","webkitAudioContext","slow","then","getMP3FileAudioBuffer","catch","withMediaSession","freeExports","freeModule","module","freeGlobal","global","self","punycode","maxInt","base","regexPunycode","regexNonASCII","regexSeparators","errors","overflow","not-basic","invalid-input","stringFromCharCode","RangeError","array","mapDomain","string","parts","split","ucs2decode","ucs2encode","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","baseMinusTMin","input","basic","oldi","w","t","baseMinusT","codePoint","inputLength","n","bias","lastIndexOf","encode","handledCPCount","basicLength","m","q","currentValue","handledCPCountPlusOne","qMinusT","version","ucs2","toASCII","toUnicode","hasOwnProperty","hexToRGB","hex","exec","parseInt","SPACING","HEIGHT","CONTAINER_HEIGHT","BAR_COLOR","SLICE_COLOR","AudioWaveformPlayer","HTMLElement","super","attachShadow","mode","renderer","shadowRoot","audioRef","handlePlayPauseClick","handleSourceTimeUpdate","handleMouseDown","handleMouseMove","handleMouseUp","handleKeyDown","pixelRatio","halfPixel","src","supportsPassiveEventListener","evtHandlerOptions","setupContainer","fetchPromise","fetch","method","headers","Accept","response","status","Error","blob","filename","match","File","fetchSource","objectURL","URL","createObjectURL","AudioContext","onAudioDecoded","audio","splitPeaks","mergedPeaks","channels","c","first","last","setLength","sampleSize","sampleStep","peaks","chan","start","end","max","setupCanvases","canvases","width","getPeaks","drawBars","drawn","duration","evt","getDuration","currentTime","percentage","round","stop","touch","touches","requestAnimationFrame","xContainer","clientX","boundingClientRect","left","container","scrollLeft","newBoundaryPos","canvasCtx","canvasContexts","clearRect","containerWidth","drawBoundary","boundary","changedTouches","x","fillStyle","fillRect","BAR_WIDTH","beginPath","arc","PI","fill","formattedTime","formatTime","textX","TIME_ANNOTATION_WIDTH","BAR_HANDLE_RADIUS","fillText","startX","partial","getImageData","imageData","progressColor","putImageData","prepareDraw","hasMinVals","offsetY","halfH","peakIndexScale","bar","step","scale","peak","h","some","val","height","canvas","snapshots","getElementById","getBoundingClientRect","querySelector","from","children","forEach","getContext","font","mediaSession","playbackState","play","pause","title","ret","getDisplayName","metadata","MediaMetadata","mediaMetadata","setMediaMetaData","setActionHandler","paused","preventDefault","togglePlayPause","disabled","progress","defineProperty","configurable","enumerable","writable","customElements","define"],"mappings":"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"}